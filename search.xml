<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[将硬盘系统装进虚拟机]]></title>
      <url>/2017/10/29/%E5%B0%86%E7%A1%AC%E7%9B%98%E7%B3%BB%E7%BB%9F%E8%A3%85%E8%BF%9B%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      <content type="html"><![CDATA[<h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>&emsp;&emsp;本文并非是虚拟机安装系统教程，而是将已经硬盘上在跑的系统通过操作安装进虚拟机。</p>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>&emsp;&emsp;在实验工作中实现<strong>“保存现有系统盘内镜像-&gt;还原”</strong>的操作一般是利用<code>dd</code>、ghost32、Total Recovery等工具或专门的备盘设备进行系统镜像备份操作，然后在硬盘镜像损坏或操作失误以后再进行镜像还原，这个过程类似虚拟机“快照”功能。如果能<strong>将做好的硬盘中的镜像做成vmdk格式虚拟硬盘镜像，即可实现在虚拟机中运行硬盘中已架好环境的系统镜像的目的</strong>，可简化一些工作流程，提高效率。<a id="more"></a>（如作为Server的提供网络、时间同步、TFTP、DHCP等服务的主机，但不适用于需系统读取系统硬件信息的测试主机，因为虚拟机内无法Cover host主机所有硬件配置）</p>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p><a href="#1">1. ghost32 硬盘镜像导出</a><br><a href="#2">2. 镜像格式转换</a><br><a href="#3">3. 新建虚拟机</a><br><a href="#4">4. 替换虚拟硬盘镜像</a><br><a href="#5">5. 虚拟机设置</a><br><a href="#6">6. 开机测试</a></p>
<h4 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h4><pre><code>测试系统：Redhat6.5
测试环境：Win7 
测试工具：ghost32 + VMware10
</code></pre><h5 id="1-ghost32-硬盘镜像导出"><a href="#1-ghost32-硬盘镜像导出" class="headerlink" title="1. ghost32 硬盘镜像导出"></a><span id="1">1. ghost32 硬盘镜像导出</span></h5><ul>
<li>进入ghost32所在文件夹，按住<code>shift</code>鼠标右键文件夹空白处打开命令行窗口，输入<code>ghost32.exe /IAL</code>调出ghost32界面，选择<code>Local</code>-&gt;<code>Disk</code>-&gt;<code>To Image</code>然后选择硬盘进行备份操作<br><em>注：  a. 勿用ghost32备份正在运行的系统，注意预留足够的空间存放备份镜像;b. ghost32 11.5.1版本可直接将镜像备份成vmdk格式，可省去第二步，直接进行第三步  
</em><br>如图<img src="/2017/10/29/将硬盘系统装进虚拟机/command.jpg" alt="command" title="command">  
<img src="/2017/10/29/将硬盘系统装进虚拟机/menu.jpg" alt="menu" title="menu">  
<img src="/2017/10/29/将硬盘系统装进虚拟机/ghosting.jpg" alt="ghosting" title="ghosting">  
</li>
</ul>
<h5 id="2-镜像格式转换"><a href="#2-镜像格式转换" class="headerlink" title="2. 镜像格式转换"></a><span id="2">2. 镜像格式转换</span></h5><p>依旧在ghost32 进行镜像格式转换，命令:<code>ghost32.exe -clone,mode=restore,src=example.GHO,dst=example.vmdk -batch -sure</code>,“example”替换为相应文件名。如图<br><img src="/2017/10/29/将硬盘系统装进虚拟机/gho2vmware.jpg" alt="gho2vmware" title="gho2vmware"><br><img src="/2017/10/29/将硬盘系统装进虚拟机/gho2vmware-ing.jpg" alt="gho2vmware-ing" title="gho2vmware-ing">  </p>
<h5 id="3-新建虚拟机"><a href="#3-新建虚拟机" class="headerlink" title="3. 新建虚拟机"></a><span id="3">3. 新建虚拟机</span></h5><p>创建新的虚拟机-&gt;典型-&gt;稍后安装操作系统-&gt;linux（版本Red Hat Enterprise Linux 6 64 位）-&gt;位置（自由设定）-&gt;磁盘大小默认，后续会替换掉-&gt;将虚拟磁盘存储为单个硬盘，完成后虚拟机信息如图<br><img src="/2017/10/29/将硬盘系统装进虚拟机/vm-client-info.jpg" alt="vm-client-info" title="vm-client-info">  </p>
<h5 id="4-替换虚拟硬盘镜像"><a href="#4-替换虚拟硬盘镜像" class="headerlink" title="4. 替换虚拟硬盘镜像"></a><span id="4">4. 替换虚拟硬盘镜像</span></h5><p>点击上图<strong>编辑虚拟机设置</strong>，选择硬盘，点击右下角<strong>移除</strong>，点击右下角<strong>添加</strong>一个硬盘，<strong>使用现有虚拟磁盘</strong>，然后选择步骤1和2生成的vmdk镜像，如图  </p>
<img src="/2017/10/29/将硬盘系统装进虚拟机/delect_HDD.jpg" alt="delect_HDD" title="delect_HDD">  
<img src="/2017/10/29/将硬盘系统装进虚拟机/select_HDD.jpg" alt="select_HDD" title="select_HDD"> 
<img src="/2017/10/29/将硬盘系统装进虚拟机/setting_HDD.jpg" alt="setting_HDD" title="setting_HDD">  
<img src="/2017/10/29/将硬盘系统装进虚拟机/setting_HDD1.jpg" alt="setting_HDD1" title="setting_HDD1">  
<img src="/2017/10/29/将硬盘系统装进虚拟机/setting_HDD_Path.jpg" alt="setting_HDD_Path" title="setting_HDD_Path">  
<h5 id="5-虚拟机设置"><a href="#5-虚拟机设置" class="headerlink" title="5. 虚拟机设置"></a><span id="5">5. 虚拟机设置</span></h5><ol>
<li>当所做系统为网络上Server使用时，可能需要使虚拟机使用host的IP地址，可做如下配置<br>点击上图<strong>编辑虚拟机设置</strong>，选择<strong>网络适配器</strong>，选择<strong>桥接</strong>，如图  <img src="/2017/10/29/将硬盘系统装进虚拟机/bridge_network.jpg" alt="bridge_network" title="bridge_network">  </li>
<li>当所做系统作为普通虚拟机，测试搭建环境等功能使用时，可使用设置<strong>网络适配器</strong>为NAT模式（新建虚拟机默认为NAT模式） </li>
</ol>
<h5 id="6-开机测试"><a href="#6-开机测试" class="headerlink" title="6. 开机测试"></a><span id="6">6. 开机测试</span></h5><img src="/2017/10/29/将硬盘系统装进虚拟机/starting1.jpg" alt="starting" title="starting">  
<img src="/2017/10/29/将硬盘系统装进虚拟机/starting.jpg" alt="starting..." title="starting...">  
<h4 id="开机调试"><a href="#开机调试" class="headerlink" title="开机调试"></a>开机调试</h4><h5 id="Error-1"><a href="#Error-1" class="headerlink" title="Error 1"></a>Error 1</h5><p>如果按正常流程，在上述步骤时，虚拟机已经可以正常使用，但是在我实际操作时，在进入开机界面以后跳出如下错误：<br><img src="/2017/10/29/将硬盘系统装进虚拟机/poweron_error.jpg" alt="poweron_error" title="poweron_error">  </p>
<ol>
<li><p>图示为内核加载时出错，尝试手动加载内核。在开机出现内核加载倒数时按<code>e</code>，出现下图界面  </p>
<img src="/2017/10/29/将硬盘系统装进虚拟机/edit_grub.jpg" alt="edit_grub" title="edit_grub">   
</li>
<li><p>在此界面按<code>c</code>，进入grub命令行模式，输入命令如下图，关于grub下操作请转文末 <a href="#II">附录II</a> ,命令需因系统配置不同而进行相应修改  </p>
<img src="/2017/10/29/将硬盘系统装进虚拟机/grub1.jpg" alt="grub1" title="grub1">   
<img src="/2017/10/29/将硬盘系统装进虚拟机/grub2.jpg" alt="grub2" title="grub2">   
</li>
<li><p>上述输入<code>boot</code>命令后即可成功启动，如下图，接下来就是进入系统修改grub文件，要不然每次启动系统都需要输入上图三个命令，不得烦死，“懒惰即美德”嘛！</p>
<img src="/2017/10/29/将硬盘系统装进虚拟机/startIssue.jpg" alt="startIssue" title="startIssue">  
</li>
</ol>
<h5 id="Error-2"><a href="#Error-2" class="headerlink" title="Error 2"></a>Error 2</h5><ol>
<li><p>在上述 Error 1 解决之后进入系统，如上图，输入密码即可运行命令，但是当对文件进行写操作时出现下图错误,更不要说更改grub文件了。。。</p>
<img src="/2017/10/29/将硬盘系统装进虚拟机/edit_issue.jpg" alt="edit_issue" title="edit_issue">  
</li>
<li><p>这时候才注意到 Error 1 步骤3的图有些不对劲，看样子像是开机时文件系统没有正常加载，查看<code>/etc/fstab</code>如下图  </p>
<img src="/2017/10/29/将硬盘系统装进虚拟机/old_fstab.jpg" alt="old_fstab" title="old_fstab">  
</li>
<li><p>想尝试修改<code>/etc/fstab</code>文件，可是由于系统没有正常加载文件系统，无法进行文件的写操作，即就算改完了这个文件，你也只能像第一步图中那样无法保存。至此事情陷入死胡同。。。</p>
</li>
<li><p>本着“办法总比困难多”的想法，尝试将之前步骤生成的vmdk虚拟硬盘通过“虚拟机添加硬盘”的方式添加到到我正常工作的虚拟机中（相当于挂载到别的系统，然后修改此虚拟硬盘内的文件后再以此虚拟硬盘做系统盘开机），然后开机，Bingo！竟然真的能读到硬盘，接下来就是<code>lsblk</code>查看硬盘分区，<code>mount</code>硬盘，修改<code>/etc/fstab</code>，具体操作如图</p>
<img src="/2017/10/29/将硬盘系统装进虚拟机/new_fstab.jpg" alt="new_fstab" title="new_fstab">  
</li>
</ol>
<img src="/2017/10/29/将硬盘系统装进虚拟机/edit_fstab.jpg" alt="edit_fstab" title="edit_fstab">  
<p><em>（此处是将我改好的fstab文件覆盖掉硬盘原来的fstab，可直接用<code>vim</code>修改）</em></p>
<ol>
<li><p>修改完后，将此虚拟机关机，重新将之前以咱们做的虚拟硬盘为主盘的系统开机，重复 Error 1 的操作开机即可发现系统已可正常开机，如下图</p>
<img src="/2017/10/29/将硬盘系统装进虚拟机/success.jpg" alt="success" title="success"> 
</li>
<li><p>接下来就是修改<code>/boot/grub/grub.conf</code>文件了,具体操作如图，第一个图为原版，注意新旧比较</p>
<img src="/2017/10/29/将硬盘系统装进虚拟机/old_grub.jpg" alt="old_grub" title="old_grub"> 
<img src="/2017/10/29/将硬盘系统装进虚拟机/new_grub.jpg" alt="new_grub" title="new_grub"> 
</li>
</ol>
<h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><h5 id="附录I"><a href="#附录I" class="headerlink" title="附录I"></a>附录I</h5><p>将 vmdk 文件转为 gho 格式命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ghost32.exe -clone,mode=create,src=example.vmdk,dst=example.gho -batch -sure</div></pre></td></tr></table></figure></p>
<h5 id="附录II"><a href="#附录II" class="headerlink" title="附录II"></a><span id="II">附录II</span></h5><p>Grub 下操作总结：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">grub&gt; root (hd0,) # 输入 root (hd0,) 这时按 TAB 键会打印出系统上所有的分区 ( 注意在急救模式下不支持 TAB , 很伤~ )</div><div class="line">Possible partitions are:</div><div class="line">Partition num: 0, Filesystem type is ext2fs, partition type 0x83</div><div class="line">Partition num: 1, Filesystem type unknown, partition type 0x82</div><div class="line">Partition num: 2, Filesystem type is ext2fs, partition type 0x83</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;0, 1, 2 代表分区编号，上面显示有文件系统，分区类型，像 83 就是 Linux 普通分区，82 是虚拟分区 SWAP ( 硬盘分区时的知识 )<br>&emsp;&emsp;这里不分 IDE / SATA 什么的，都用 hd 代表，hd0 代表第一块硬盘，hd0,0 代表第一块硬盘的第一个分区，系统中是用 sda1 代表第一块硬盘的第一个分区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grub&gt; root (hd0,0)/</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;输入 root (hd0,0)/ 这里按 TAB 键搜索内核在不在此分区上 ( boot 分区 )，如果有会输出下面信息 ( 试 83 的分区，82 是交换分区就没必要试了 )<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Possible files are: lost+found grub efi .VMlinuz-2.6.32-504.e16.x86_64.hmac System.map-2.6.32-504.e16.x86_64 config-2.6.32-504.x86_64 symvers-2.6.32-504.x86_64.gz VMlinuz-2.6.32-504.e16.x86_64 initramfs-2.6.32-504.e16.x86_64.img</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;如果可以看到 vmlinuz- 跟 initramfs- 字样，说明这就是我们想要的东西<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grub&gt; root (hd0,2)/</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;下面是搜不到的显示, 仔细看看 ( 发现这是根分区哎~~ hd0,2 是根分区，我们用的是 SATA , 所以根分区是 /dev/sda3 很有用 ！)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Possible files are: lost+found boot dev proc sys var tmp etc root selinux lib64 usr bin home lib media mnt opt sbin srv .autorelabel</div></pre></td></tr></table></figure></p>
<p><strong>绑定启动分区</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">grub&gt; root (hd0,0) </div><div class="line">Filesystem type is ext2fs, partition type 0x83</div><div class="line"></div><div class="line">grub&gt; kernel /VMlinuz-2.6.32-504.e16.x86_64 ro root=/dev/sda3 # 指定启动内核，ro 只读模式，root= 指定根分区, 一定要指对 ( 可能如果 boot 没有单独分区不指定也是可以的 )</div><div class="line"></div><div class="line">grub&gt; initrd /initramfs-2.6.32-504.e16.x86_64.img # 这是内核映像吧 ( kernel 、initrd 都是上面搜出来的，输入一点点按 TAB 可以补全 )</div><div class="line"></div><div class="line">grub&gt; boot # 启动系统，手动编写 grub.conf 或恢复备份</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Vmware </category>
            
            <category> 系统安装 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> VMware </tag>
            
            <tag> 系统安装 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[搭梯子：Shadowsocks 一键安装脚本（四合一）]]></title>
      <url>/2017/10/23/%E6%90%AD%E6%A2%AF%E5%AD%90%EF%BC%9AShadowsocks-%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC%EF%BC%88%E5%9B%9B%E5%90%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p><strong><em>转自文章 <a href="https://teddysun.com/486.html" target="_blank" rel="external">Shadowsocks 一键安装脚本（四合一）</a></em></strong></p>
<h4 id="本脚本适用环境"><a href="#本脚本适用环境" class="headerlink" title="本脚本适用环境"></a>本脚本适用环境</h4><p>系统支持：CentOS 6+，Debian 7+，Ubuntu 12+<br>内存要求：≥128M</p>
<font color="#DC143C">日期　　：2017 年 10 月 22 日</font>


<h4 id="关于本脚本"><a href="#关于本脚本" class="headerlink" title="关于本脚本"></a>关于本脚本</h4><ol>
<li>一键安装 Shadowsocks-Python， ShadowsocksR， Shadowsocks-Go， Shadowsocks-libev 版（四选一）服务端；</li>
<li>各版本的启动脚本及配置文件名不再重合；</li>
<li>每次运行可安装一种版本；</li>
<li>支持以多次运行来安装多个版本，且各个版本可以共存（注意端口号需设成不同）；</li>
<li>若已安装多个版本，则卸载时也需多次运行（每次卸载一种）；</li>
<li>Shadowsocks-Python 和 ShadowsocksR 安装后不可同时启动（因为本质上都属 Python 版）。</li>
</ol>
<p><font color="#DC143C"><strong>友情提示</strong>：</font>如果你有问题，请先阅读这篇《<a href="https://teddysun.com/399.html" target="_blank" rel="external">Shadowsocks Troubleshooting</a>》之后再询问。<br><a id="more"></a></p>
<h4 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h4><p>服务器端口：自己设定（如不设定，默认为 8989）<br>密码：自己设定（如不设定，默认为 teddysun.com）<br>加密方式：自己设定（如不设定，Python 和 libev 版默认为 aes-256-gcm，R 和 Go 版默认为 aes-256-cfb）<br>协议（protocol）：自己设定（如不设定，默认为 origin）（仅限 ShadowsocksR 版）<br>混淆（obfs）：自己设定（如不设定，默认为 plain）（仅限 ShadowsocksR 版）<br><strong>备注</strong>：脚本默认创建单用户配置文件，如需配置多用户，请手动修改相应的配置文件后重启即可。</p>
<h4 id="客户端下载"><a href="#客户端下载" class="headerlink" title="客户端下载"></a>客户端下载</h4><p>常规版 Windows 客户端<br><a href="https://github.com/shadowsocks/shadowsocks-windows/releases" target="_blank" rel="external">https://github.com/shadowsocks/shadowsocks-windows/releases</a></p>
<p>ShadowsocksR 版 Windows 客户端<br><a href="https://github.com/shadowsocksr/shadowsocksr-csharp/releases" target="_blank" rel="external">https://github.com/shadowsocksr/shadowsocksr-csharp/releases</a></p>
<p>Android/MAC/Windows 客户端<br>百度云链接：<a href="https://pan.baidu.com/s/1pLkeXFt" target="_blank" rel="external">https://pan.baidu.com/s/1pLkeXFt</a> 密码: uv9i</p>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><h5 id="使用root用户登录，运行以下命令："><a href="#使用root用户登录，运行以下命令：" class="headerlink" title="使用root用户登录，运行以下命令："></a>使用root用户登录，运行以下命令：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh</div><div class="line">chmod +x shadowsocks-all.sh</div><div class="line">./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log</div></pre></td></tr></table></figure>
<h5 id="安装完成后，脚本提示如下"><a href="#安装完成后，脚本提示如下" class="headerlink" title="安装完成后，脚本提示如下"></a>安装完成后，脚本提示如下</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Congratulations, your_shadowsocks_version install completed!</div><div class="line">Your Server IP        :your_server_ip</div><div class="line">Your Server Port      :your_server_port</div><div class="line">Your Password         :your_password</div><div class="line">Your Encryption Method:your_encryption_method</div><div class="line"></div><div class="line">Welcome to visit:https://teddysun.com/486.html</div><div class="line">Enjoy it!  </div></pre></td></tr></table></figure>
<h5 id="卸载方法"><a href="#卸载方法" class="headerlink" title="卸载方法"></a>卸载方法</h5><p>若已安装多个版本，则卸载时也需多次运行（每次卸载一种）</p>
<p>使用root用户登录，运行以下命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./shadowsocks-all.sh uninstall</div></pre></td></tr></table></figure></p>
<h5 id="启动脚本"><a href="#启动脚本" class="headerlink" title="启动脚本"></a>启动脚本</h5><p>启动脚本后面的参数含义，从左至右依次为：启动，停止，重启，查看状态。</p>
<p>Shadowsocks-Python 版：<br>/etc/init.d/shadowsocks-python start | stop | restart | status</p>
<p>ShadowsocksR 版：<br>/etc/init.d/shadowsocks-r start | stop | restart | status</p>
<p>Shadowsocks-Go 版：<br>/etc/init.d/shadowsocks-go start | stop | restart | status</p>
<p>Shadowsocks-libev 版：<br>/etc/init.d/shadowsocks-libev start | stop | restart | status</p>
<h5 id="各版本默认配置文件"><a href="#各版本默认配置文件" class="headerlink" title="各版本默认配置文件"></a>各版本默认配置文件</h5><p>Shadowsocks-Python 版：<br>/etc/shadowsocks-python/config.json</p>
<p>ShadowsocksR 版：<br>/etc/shadowsocks-r/config.json</p>
<p>Shadowsocks-Go 版：<br>/etc/shadowsocks-go/config.json</p>
<p>Shadowsocks-libev 版：<br>/etc/shadowsocks-libev/config.json</p>
<h4 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h4><h5 id="2017-年-10-月-22-日："><a href="#2017-年-10-月-22-日：" class="headerlink" title="2017 年 10 月 22 日："></a>2017 年 10 月 22 日：</h5><p>1、升级：libsodium 到 1.0.15。</p>
<h5 id="2017-年-10-月-14-日："><a href="#2017-年-10-月-14-日：" class="headerlink" title="2017 年 10 月 14 日："></a>2017 年 10 月 14 日：</h5><p>1、新增：在安装 Shadowsocks-libev 版时可选安装 simple-obfs 服务端。<br>※ 脚本通过判断 autoconf 版本是否大于或等于 2.67 来一键安装 simple-obfs 服务端。并且，支持在安装过程中选择 obfs 为 http 或 tls。<br>※ 使用方法参考：<a href="https://teddysun.com/511.html" target="_blank" rel="external">https://teddysun.com/511.html</a></p>
<h5 id="2017-年-09-月-16-日："><a href="#2017-年-09-月-16-日：" class="headerlink" title="2017 年 09 月 16 日："></a>2017 年 09 月 16 日：</h5><p>1、修正：Shadowsocks-libev 版 v3.1.0 使用 libc-ares 替换 libudns 依赖包，解决了依赖问题；<br>2、升级：mbedtls 到版本 2.6.0。</p>
<h5 id="2017-年-07-月-27-日："><a href="#2017-年-07-月-27-日：" class="headerlink" title="2017 年 07 月 27 日："></a>2017 年 07 月 27 日：</h5><p>1、新增：ShadowsocksR 版可选协议（protocol）auth_chain_b 。使用该协议需更新到最新（4.7.0） ShadowsocksR 版客户端；<br>2、修改：更新 ShadowsocksR 源码下载地址。</p>
<h5 id="2017-年-07-月-23-日："><a href="#2017-年-07-月-23-日：" class="headerlink" title="2017 年 07 月 23 日："></a>2017 年 07 月 23 日：</h5><p>1、修正：卸载时可自行选择某个版本卸载，若该版本不存在则报错退出。</p>
<h5 id="2017-年-07-月-22-日："><a href="#2017-年-07-月-22-日：" class="headerlink" title="2017 年 07 月 22 日："></a>2017 年 07 月 22 日：</h5><p>1、修正：默认加密方式从 aes-256-cfb 改为 aes-256-gcm（Python 和 libev 版）；<br>2、新增：安装时可选 16 种加密方式的其中之一（Python 和 libev 版）。如下所示：</p>
<p>aes-256-gcm<br>aes-192-gcm<br>aes-128-gcm<br>aes-256-ctr<br>aes-192-ctr<br>aes-128-ctr<br>aes-256-cfb<br>aes-192-cfb<br>aes-128-cfb<br>camellia-128-cfb<br>camellia-192-cfb<br>camellia-256-cfb<br>chacha20-ietf-poly1305<br>chacha20-ietf<br>chacha20<br>rc4-md5<br>3、新增：安装时可选 9 种加密方式的其中之一（Go 版）。如下所示：</p>
<p>aes-256-cfb<br>aes-192-cfb<br>aes-128-cfb<br>aes-256-ctr<br>aes-192-ctr<br>aes-128-ctr<br>chacha20-ietf<br>chacha20<br>rc4-md5<br>4、新增：安装时可选 13 种加密方式的其中之一（none 是不加密，ShadowsocksR 版）。如下所示：</p>
<p>none<br>aes-256-cfb<br>aes-192-cfb<br>aes-128-cfb<br>aes-256-cfb8<br>aes-192-cfb8<br>aes-128-cfb8<br>aes-256-ctr<br>aes-192-ctr<br>aes-128-ctr<br>chacha20-ietf<br>chacha20<br>rc4-md5<br>rc4-md5-6<br>5、新增：安装时可选 7 种协议（protocol）的其中之一（仅限 ShadowsocksR 版）。如下所示：</p>
<p>origin<br>verify_deflate<br>auth_sha1_v4<br>auth_sha1_v4_compatible<br>auth_aes128_md5<br>auth_aes128_sha1<br>auth_chain_a<br>auth_chain_b<br>6、新增：安装时可选 9 种混淆（obfs）的其中之一（仅限 ShadowsocksR 版）。如下所示：</p>
<p>plain<br>http_simple<br>http_simple_compatible<br>http_post<br>http_post_compatible<br>tls1.2_ticket_auth<br>tls1.2_ticket_auth_compatible<br>tls1.2_ticket_fastauth<br>tls1.2_ticket_fastauth_compatible</p>
<h5 id="2017-年-02-月-24-日："><a href="#2017-年-02-月-24-日：" class="headerlink" title="2017 年 02 月 24 日："></a>2017 年 02 月 24 日：</h5><p>1、恢复： 通过 Github API 自动获取 Shadowsocks-libev 的最新 release 版本的功能（v3.0.3）。</p>
<h5 id="2017-年-02-月-13-日："><a href="#2017-年-02-月-13-日：" class="headerlink" title="2017 年 02 月 13 日："></a>2017 年 02 月 13 日：</h5><p>1、升级： Shadowsocks-libev 版到版本 3.0.2；<br>2、升级： Shadowsocks-go 版到版本 1.2.1（基于 Github 最新代码，用 go 1.8 编译完成的 x86 和 x86_64 二进制文件）；<br>3、修复：在 Debian 7 下默认没有 libudns-dev 依赖包的问题。</p>
<h5 id="2017-年-02-月-12-日："><a href="#2017-年-02-月-12-日：" class="headerlink" title="2017 年 02 月 12 日："></a>2017 年 02 月 12 日：</h5><p>1、升级： Shadowsocks-libev 版到版本 3.0.1。</p>
<h5 id="2017-年-01-月-27-日："><a href="#2017-年-01-月-27-日：" class="headerlink" title="2017 年 01 月 27 日："></a>2017 年 01 月 27 日：</h5><p>1、升级： Shadowsocks-go 版到版本 1.2.1 （仅适用于 x86_64 系统）</p>
<h5 id="更多单版本-Shadowsocks-服务端一键安装脚本"><a href="#更多单版本-Shadowsocks-服务端一键安装脚本" class="headerlink" title="更多单版本 Shadowsocks 服务端一键安装脚本"></a>更多单版本 Shadowsocks 服务端一键安装脚本</h5><p>Shadowsocks Python 版一键安装脚本（CentOS，Debian，Ubuntu）<br>ShadowsocksR 版一键安装脚本（CentOS，Debian，Ubuntu）<br>CentOS 下 Shadowsocks-libev 一键安装脚本<br>Debian 下 Shadowsocks-libev 一键安装脚本<br>Shadowsocks-go 一键安装脚本（CentOS，Debian，Ubuntu）</p>
<p><strong>注意：以上单版本不可与该四合一版本混用。</strong></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redhat/Ununtu16.04 添加服务]]></title>
      <url>/2017/10/22/Redhat-Ununtu16-04-%E6%B7%BB%E5%8A%A0%E6%9C%8D%E5%8A%A1/</url>
      <content type="html"><![CDATA[<blockquote>
<p>&emsp;&emsp;上周在架设<a href="https://gitea.io/zh-CN/" target="_blank" rel="external">Gitea</a>Server做个人代码管理器时，运行网页设置界面时需运行<code>路径/gitea web</code>命令，Ctrl+C 退出运行命令时网页版就会停止服务，本着<strong>懒即美德</strong>的原则，想就此做优化，预期目标是：在我想运行网页版时不需要打上一长串“难记”的路径，想停止命令时又不用 <code>kill</code>来退出它。<br>&emsp;&emsp;首先想到的是写一个脚本，然后运行脚本就可以运行/停止软件，想加入开机启动，只需要再更改 <code>.bash_profile</code> 即可。这些工作做完，重启机器，软件与预期一样，开机时候已经后台启动。Perfect！哎，等等，那我想要关掉它捏？？？好吧，最后还是决定，把它设置为开机自启动服务吧，这样就可以通过<code>service xxx start|stop|restart|status</code>控制它了！<br><a id="more"></a></p>
<h4 id="Redhat6-5-下服务配置"><a href="#Redhat6-5-下服务配置" class="headerlink" title="Redhat6.5 下服务配置"></a>Redhat6.5 下服务配置</h4><h5 id="新建-etc-gitea-将gitea各文件放入。目录可自行定义，非必须此位置"><a href="#新建-etc-gitea-将gitea各文件放入。目录可自行定义，非必须此位置" class="headerlink" title="新建/etc/gitea,将gitea各文件放入。目录可自行定义，非必须此位置"></a>新建/etc/gitea,将gitea各文件放入。目录可自行定义，非必须此位置</h5><h5 id="新建-startGitea-sh用来启动gitea，内容如下"><a href="#新建-startGitea-sh用来启动gitea，内容如下" class="headerlink" title="新建 startGitea.sh用来启动gitea，内容如下"></a>新建 startGitea.sh用来启动gitea，内容如下</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line">cd /etc/gitea</div><div class="line">nohup ./gitea web &gt; /dev/null 2&gt;&amp;1 &amp;</div></pre></td></tr></table></figure>
<h5 id="设置脚本gitd-sh-start-stop-restart-status"><a href="#设置脚本gitd-sh-start-stop-restart-status" class="headerlink" title="设置脚本gitd.sh  start|stop|restart|status"></a>设置脚本gitd.sh  start|stop|restart|status</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"></div><div class="line"><span class="meta">#</span>description: gitd.sh</div><div class="line"><span class="meta">#</span>chkconfig: 2345 20 81</div><div class="line"></div><div class="line">SERVICEEXEC=gitea</div><div class="line">EXEC_PATH=/etc/gitea/</div><div class="line">EXEC=startGitea.sh</div><div class="line">DAEMON=$EXEC_PATH$EXEC</div><div class="line">PID_FILE=/var/run/startGitea.sh.pid</div><div class="line"></div><div class="line">. /etc/rc.d/init.d/functions</div><div class="line"></div><div class="line">if [ ! -x $DAEMON ] ; then</div><div class="line">echo "ERROR: $DAEMON not found"</div><div class="line">exit 1</div><div class="line">fi</div><div class="line"></div><div class="line">stop()</div><div class="line">&#123;</div><div class="line">echo "Stoping $EXEC ..."</div><div class="line"><span class="meta">#</span>ps aux | grep "$DAEMON" | kill -9 `awk '&#123;print $2&#125;'` &gt;/dev/null 2&gt;&amp;1</div><div class="line">ps aux | grep "$SERVICEEXEC" | kill -9 `awk '&#123;print $2&#125;'` &gt;/dev/null 2&gt;&amp;1</div><div class="line">rm -f $PID_FILE</div><div class="line">usleep 100</div><div class="line">echo "Shutting down $EXEC: [  OK  ]"</div><div class="line">&#125;</div><div class="line"></div><div class="line">start()</div><div class="line">&#123;</div><div class="line">echo "Starting $EXEC ..."</div><div class="line">if [ `ps aux | grep "$SERVICEEXEC" | awk '&#123;print $2&#125;'|wc -l` -le 1 ];then</div><div class="line"><span class="meta">$</span>DAEMON &gt; /dev/null &amp;</div><div class="line">pidof $EXEC &gt; $PID_FILE</div><div class="line">usleep 100</div><div class="line">echo "Starting $EXEC: [  OK  ]"</div><div class="line">else</div><div class="line">echo "gitea is running now ! "</div><div class="line">fi</div><div class="line">&#125;</div><div class="line"></div><div class="line">restart()</div><div class="line">&#123;</div><div class="line">stop</div><div class="line">start</div><div class="line">&#125;</div><div class="line"></div><div class="line">status()</div><div class="line">&#123;</div><div class="line">if [ `ps aux | grep "$SERVICEEXEC" | awk '&#123;print $2&#125;'|wc -l` -le 1 ];then</div><div class="line">echo "gitea is not running ! "</div><div class="line">else</div><div class="line">echo "gitea is running now ! "</div><div class="line">fi</div><div class="line">&#125;</div><div class="line"></div><div class="line">case "$1" in</div><div class="line">start)</div><div class="line">start</div><div class="line">;;</div><div class="line">stop)</div><div class="line">stop</div><div class="line">;;</div><div class="line">restart)</div><div class="line">restart</div><div class="line">;;</div><div class="line">status)</div><div class="line">status -p $PID_FILE $DAEMON</div><div class="line">;;</div><div class="line">*)</div><div class="line">echo "Usage: service $EXEC &#123;start|stop|restart|status&#125;"</div><div class="line">exit 1</div><div class="line">esac</div><div class="line"></div><div class="line">exit $?</div></pre></td></tr></table></figure>
<h5 id="将脚本新建软链接到-etc-init-d"><a href="#将脚本新建软链接到-etc-init-d" class="headerlink" title="将脚本新建软链接到 /etc/init.d/"></a>将脚本新建软链接到 <code>/etc/init.d/</code></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ln -s /etc/gitea/gitd.sh /etc/init.d/gitd</div></pre></td></tr></table></figure>
<h5 id="设置开机自启动"><a href="#设置开机自启动" class="headerlink" title="设置开机自启动"></a>设置开机自启动</h5><ol>
<li>在chkconfig工具服务列表中增加此服务<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chkconfig --add gitd </div></pre></td></tr></table></figure></li>
<li>修改服务的默认启动等级<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chkconfig gitd on</div></pre></td></tr></table></figure>  
</li>
</ol>
</blockquote>
<h5 id="查看-删除服务"><a href="#查看-删除服务" class="headerlink" title="查看/删除服务"></a>查看/删除服务</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chkconfig --list|grep gitd</div><div class="line">chkconfig --del gitd</div></pre></td></tr></table></figure>
<hr>
<h4 id="Ubuntu16-04-下服务配置"><a href="#Ubuntu16-04-下服务配置" class="headerlink" title="Ubuntu16.04 下服务配置"></a>Ubuntu16.04 下服务配置</h4><blockquote>
<p>类比上文 “redhat6.5将脚本注册为服务”</p>
</blockquote>
<h5 id="同Redhat-第1步"><a href="#同Redhat-第1步" class="headerlink" title="同Redhat 第1步"></a>同Redhat 第1步</h5><h5 id="设置服务脚本（注意BEGIN-INIT-INFO至END-INIT-INFO部分）"><a href="#设置服务脚本（注意BEGIN-INIT-INFO至END-INIT-INFO部分）" class="headerlink" title="设置服务脚本（注意BEGIN INIT INFO至END INIT INFO部分）"></a>设置服务脚本（注意<code>BEGIN INIT INFO</code>至<code>END INIT INFO</code>部分）</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"></div><div class="line"><span class="meta">#</span>## BEGIN INIT INFO</div><div class="line"><span class="meta">#</span> Provides:          Gitd</div><div class="line"><span class="meta">#</span> Required-Start:    $network $local_fs $remote_fs</div><div class="line"><span class="meta">#</span> Required-Stop:     $network $local_fs $remote_fs</div><div class="line"><span class="meta">#</span> Default-Start:     2 3 4 5</div><div class="line"><span class="meta">#</span> Default-Stop:      0 1 6</div><div class="line"><span class="meta">#</span> Short-Description: The git server --- Gitea</div><div class="line"><span class="meta">#</span> Description:       Start or stop the ShadowsocksR server</div><div class="line"><span class="meta">#</span>## END INIT INFO</div><div class="line"></div><div class="line">SERVICEEXEC=gitea</div><div class="line">EXEC_PATH=/etc/gitea/</div><div class="line">EXEC=startGitea.sh</div><div class="line">DAEMON=$EXEC_PATH$EXEC</div><div class="line">PID_FILE=/var/run/startGitea.sh.pid</div><div class="line"></div><div class="line"><span class="meta">#</span>. /etc/rc.d/init.d/functions</div><div class="line"></div><div class="line">if [ ! -x $DAEMON ] ; then</div><div class="line">echo "ERROR: $DAEMON not found"</div><div class="line">exit 1</div><div class="line">fi</div><div class="line"></div><div class="line">stop()</div><div class="line">&#123;</div><div class="line">echo "Stoping $EXEC ..."</div><div class="line"><span class="meta">#</span>ps aux | grep "$DAEMON" | kill -9 `awk '&#123;print $2&#125;'` &gt;/dev/null 2&gt;&amp;1</div><div class="line">ps aux | grep "$SERVICEEXEC" | kill -9 `awk '&#123;print $2&#125;'` &gt;/dev/null 2&gt;&amp;1</div><div class="line">rm -f $PID_FILE</div><div class="line">sleep 0.1</div><div class="line">echo "Shutting down $EXEC: [  OK  ]"</div><div class="line">&#125;</div><div class="line"></div><div class="line">start()</div><div class="line">&#123;</div><div class="line">echo "Starting $EXEC ..."</div><div class="line">if [ `ps aux | grep "$SERVICEEXEC" |grep -v grep | awk '&#123;print $2&#125;'|wc -l` -le 2 ];then</div><div class="line"><span class="meta">$</span>DAEMON &gt; /dev/null &amp;</div><div class="line">pidof $EXEC &gt; $PID_FILE</div><div class="line">sleep 0.1</div><div class="line">echo "Starting $EXEC: [  OK  ]"</div><div class="line">else</div><div class="line">echo "gitea is running now ! "</div><div class="line">fi</div><div class="line">&#125;</div><div class="line"></div><div class="line">restart()</div><div class="line">&#123;</div><div class="line">stop</div><div class="line">start</div><div class="line">&#125;</div><div class="line"></div><div class="line">status()</div><div class="line">&#123;</div><div class="line">if [ `ps aux | grep "$SERVICEEXEC" | awk '&#123;print $2&#125;'|wc -l` -le 1 ];then</div><div class="line">echo "gitea is not running ! "</div><div class="line">else</div><div class="line">echo "gitea is running now ! "</div><div class="line">fi</div><div class="line">&#125;</div><div class="line"></div><div class="line">case "$1" in</div><div class="line">start)</div><div class="line">start</div><div class="line">;;</div><div class="line">stop)</div><div class="line">stop</div><div class="line">;;</div><div class="line">restart)</div><div class="line">restart</div><div class="line">;;</div><div class="line">status)</div><div class="line">status -p $PID_FILE $DAEMON</div><div class="line">;;</div><div class="line">*)</div><div class="line">echo "Usage: service $EXEC &#123;start|stop|restart|status&#125;"</div><div class="line">exit 1</div><div class="line">esac</div><div class="line"></div><div class="line">exit $?</div></pre></td></tr></table></figure>
<h5 id="添加服务"><a href="#添加服务" class="headerlink" title="添加服务"></a>添加服务</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ln -s xxxxx /etc/init.d/gitd</div><div class="line">update-rc.d -f gitd defaults</div></pre></td></tr></table></figure>
<p>删除：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">update-rc.d -f gitd remove</div></pre></td></tr></table></figure></p>
<h5 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">systemctl daemon-reload    （更新服务后需要执行这一步）</div><div class="line">service gitd restart</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SVN服务器进阶-VisualSVN-Server和TortoiseSVN]]></title>
      <url>/2017/10/16/SVN%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E9%98%B6-VisualSVN-Server%E5%92%8CTortoiseSVN%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h5 id="VisualSVN-Server介绍"><a href="#VisualSVN-Server介绍" class="headerlink" title="VisualSVN Server介绍"></a>VisualSVN Server介绍</h5><p>VisualSVN Server是免费的，而VisualSVN是收费的。VisualSVN是SVN的客户端，和Visual Studio集成在一起， VisualSvn Server是SVN的服务器端，包括Subversion、Apache和用户及权限管理</p>
<h5 id="VisualSVN相较Subversion优势"><a href="#VisualSVN相较Subversion优势" class="headerlink" title="VisualSVN相较Subversion优势"></a>VisualSVN相较Subversion优势</h5><p>如果直接使用Subversion，那么在Windows 系统上，要想让它随系统启动，就要封装SVN Server为windws service，还要通过修改配置文件来控制用户权限，另外如果要想以Web方式–“http协议访问”，一般还要安装配置Apache，对于新手十分不友好，而VisualSVN Serve集成了Subversion和Apache，省去了以上所有的麻烦。安装的时候SVN Server已经封装为windws service，Apache服务器的配置也只是在图像界面上，指定认证方式、访问端口等简单操作；另外，用户权限的管理也是通过图像界面来配置。<br><a id="more"></a></p>
<h5 id="VisualSVN安装下载"><a href="#VisualSVN安装下载" class="headerlink" title="VisualSVN安装下载"></a>VisualSVN安装下载</h5><h6 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h6><p>下载地址：<a href="https://www.visualsvn.com/downloads/" target="_blank" rel="external">https://www.visualsvn.com/downloads/</a></p>
<img src="/2017/10/16/SVN服务器进阶-VisualSVN-Server和TortoiseSVN配置/download.jpg" alt="downloadVisualSVN" title="downloadVisualSVN">
<p>选择VisualSVN Server，选择32/64位下载</p>
<h6 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h6><p>软件安装一步步选择默认配置即可，当安装流程到如下图时选择<code>Standard Edition</code>即可<br><br>安装到下图时可对软件安装目录和资源库所在的位置及端口号进行设置，如果用默认的HTTPS，端口有443和8443，如果不用HTTPS，端口就是80和8080，如下图。此处可先保持默认设置，可在软件启动后进行设置<br><img src="/2017/10/16/SVN服务器进阶-VisualSVN-Server和TortoiseSVN配置/https.jpg" alt="https" title="https"><br><img src="/2017/10/16/SVN服务器进阶-VisualSVN-Server和TortoiseSVN配置/http.jpg" alt="http" title="http">  </p>
<h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>整体界面，左边从上到下是SVN本地服务器、资源库、用户、用户组等。<br>右边从上到下是服务状态、日志信息及配置、认证信息及配置、资源库信息及配置。最下面有更新，版本号之类的<br><img src="/2017/10/16/SVN服务器进阶-VisualSVN-Server和TortoiseSVN配置/menu.jpg" alt="menu" title="menu"><br>打开电脑服务，可看到已经生成了相应的服务<br><img src="/2017/10/16/SVN服务器进阶-VisualSVN-Server和TortoiseSVN配置/serve.jpg" alt="serve" title="serve"><br>如下图，右键SVN本地服务器，“Properties”可对服务器进行资源库，http类型及端口等设置，在此不过多介绍<br><img src="/2017/10/16/SVN服务器进阶-VisualSVN-Server和TortoiseSVN配置/properties.jpg" alt="properties" title="properties">  </p>
<h6 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h6><ol>
<li>如图右键<code>Repositories</code>,选择<code>Creat New Repository</code>或者<code>新建</code>-&gt;<code>Repository</code>  <img src="/2017/10/16/SVN服务器进阶-VisualSVN-Server和TortoiseSVN配置/new_properties1.jpg" alt="new_properties1" title="new_properties1">  </li>
<li>此处科普一下两种repository不同。<a href="#1">①</a>  <img src="/2017/10/16/SVN服务器进阶-VisualSVN-Server和TortoiseSVN配置/multisite-replication.jpg" alt="multisite-replication" title="multisite-replication">  </li>
<li>仓库结构，这里选第一个空的，下面那个在建成后会自动存在三个文件夹:trunk,branches,tags  <img src="/2017/10/16/SVN服务器进阶-VisualSVN-Server和TortoiseSVN配置/new_properties2.jpg" alt="new_properties2" title="new_properties2">  </li>
<li>仓库的访问权限设置，Nobody has access是所人有都不可访问，第二个是所有的SVN用户都可以读写，最后是自定义权限，按默认的来吧！  <img src="/2017/10/16/SVN服务器进阶-VisualSVN-Server和TortoiseSVN配置/new_properties3.jpg" alt="new_properties3" title="new_properties3">  </li>
<li>最后显示配置的仓库类型为FSFS，仓库名是”test1”，URL是 “<a href="https://pedro-PC/svn/test1" target="_blank" rel="external">https://pedro-PC/svn/test1</a>“ ，因为我们用的是https协议，<em>“pedro-PC”</em>可以用IP代替，<em>“pedro-PC/svn”</em>是根目录,<em>“svn/test1”</em>是虚拟的SVN目录，并不是我们设置的实际目录，权限默认为所有人可读写。  <img src="/2017/10/16/SVN服务器进阶-VisualSVN-Server和TortoiseSVN配置/new_properties4.jpg" alt="new_properties4" title="new_properties4">  </li>
<li>访问”<a href="https://pedro-PC/svn/test1" target="_blank" rel="external">https://pedro-PC/svn/test1</a>“ ，如图，则表示安装成功。  <img src="/2017/10/16/SVN服务器进阶-VisualSVN-Server和TortoiseSVN配置/new_properties5.jpg" alt="new_properties5" title="new_properties5">  </li>
<li>右键新建好的仓库，弹出的菜单中，可通过<code>Properties</code>设置可访问仓库的用户，用户的创建则可通过<code>Users</code>,<code>Groups</code>菜单操作。  <img src="/2017/10/16/SVN服务器进阶-VisualSVN-Server和TortoiseSVN配置/new_properties6.jpg" alt="new_properties6" title="new_properties6">  </li>
<li>接下来就靠读者自行探索了。可参考“Subversion+TortoiseSVN”组合。</li>
</ol>
<h5 id="TortiseSVN-检出操作提醒"><a href="#TortiseSVN-检出操作提醒" class="headerlink" title="TortiseSVN 检出操作提醒"></a>TortiseSVN 检出操作提醒</h5><p>在我最初架好Server端后，从svn做下载动作，checkout的时候老是弹出如下问题<br><img src="/2017/10/16/SVN服务器进阶-VisualSVN-Server和TortoiseSVN配置/new_properties7.jpg" alt="new_properties7" title="new_properties7"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">The XML response contains invalid XML</div><div class="line">Malformed XML: no element found</div></pre></td></tr></table></figure></p>
<p>先是检查了N遍Server，没有问题，又按百度的方法clear了N次都不行。<br>原因：在服务器访问仓库时，只需输入<code>http://IP/</code>即可，但是在使用TortoiseSVN同步时，地址应写完整<br>正确的地址：<br><a href="https://IP/svn/xxx" target="_blank" rel="external">https://IP/svn/xxx</a></p>
<h5 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h5><h6 id="FSFS与VDFS"><a href="#FSFS与VDFS" class="headerlink" title="FSFS与VDFS"></a><span id="1">FSFS与VDFS</span></h6><p>VDFS是基于FSFS的，公司的官网有介绍：<a href="https://www.visualsvn.com/server/features/multisite-replication/" target="_blank" rel="external">VisualSVN Server</a></p>
<blockquote>
<p>It’s worth to notice that VDFS data store is built on top of the standard    FSFS backend. The existing FSFS-based repositories can be instantly    converted into a VDFS repository. Moreover, there is no data lock-in and you    can instantly convert a VDFS repository back into a regular FSFS-based    repository.   </p>
</blockquote>
<p>简单来说这个是VisualSVN基于FSFS文件系统格式扩展的，根据wikipedia的说法：<a href="https://en.wikipedia.org/wiki/VisualSVN_Server" target="_blank" rel="external">VisualSVN Server</a></p>
<blockquote>
<p>VisualSVN Distributed File System (VDFS). Multisite Repository Replication is based on VDFS technology. VDFS enables automatic, transparent, bidirectional replication of Subversion repositories between multiple locations (each slave repository is writeable). VDFS follows the classic master / slave replication architecture and uses Microsoft RPC as its transport layer.</p>
</blockquote>
<p>也就是说，分布式版本管理DVCS兴起之后，大家发现多个仓库的好处了，开始给SVN增加这个功能。至于FSFS本身是SVN在2004年开始替换Berkeley DB的，是基于文件系统概念设计的，而不是基于数据库的概念，根据 <a href="http://svnbook.red-bean.com/en/1.1/ch05.html" target="_blank" rel="external">http://svnbook.red-bean.com/en/1.1/ch05.html</a>的说法，采用目录树的结构去做transaction，可以在目录外创建完一次提交，然后把完成的提交一次性移动进版本历史。另外，根据他们的数据结构，对Berkeley DB的append操作是O(N^2)的，而FSFS是O(N)的。当然更完整的介绍可以看：<a href="http://svn.apache.org/repos/asf/subversion/tags/1.8.4/notes/fsfs" target="_blank" rel="external">http://svn.apache.org/repos/asf/subversion/tags/1.8.4/notes/fsfs</a>如果你不是太在乎私有格式，也需要多仓库同步，可以用VDFS，官方文档说了VDFS默认的service是没有启动的，所以对你日常应该没有影响。如果不喜欢私有格式，就用FSFS就好。</p>
]]></content>
      
        <categories>
            
            <category> SVN </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SVN </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SVN服务器搭建--Subversio和TortoiseSVN配置]]></title>
      <url>/2017/10/15/SVN%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA-Subversion%E5%92%8CTortoiseSVN%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;<strong>本文主要介绍Windows下SVN组合：Subversion和TortoiseSVN安装配置</strong></p>
<h5 id="软件下载："><a href="#软件下载：" class="headerlink" title="软件下载："></a>软件下载：</h5><ul>
<li>Subversion ：<a href="https://www.visualsvn.com/downloads/" target="_blank" rel="external">https://www.visualsvn.com/downloads/</a></li>
<li>TortoiseSVN ：<a href="https://www.visualsvn.com/visualsvn/download/tortoisesvn/" target="_blank" rel="external">https://www.visualsvn.com/visualsvn/download/tortoisesvn/</a>  </li>
</ul>
<h5 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h5><ol>
<li>Subversion：按照默认安装，一直<code>next</code>即可</li>
<li>TortoiseSVN：同样按照默认安装即可，由于和资源管理器集成的，所以装后要重启。<br><strong>服务器端：Subversion（+TortoiseSVN）</strong><br><strong>客户端：TortoiseSVN</strong><a id="more"></a>
<h5 id="配置："><a href="#配置：" class="headerlink" title="配置："></a>配置：</h5></li>
<li>创建仓库，即创建一个保存你的代码历史的目录，两种方法：<ul>
<li>使用SubVersion的命令：进入命令行，CD到SubVersion/bin目录，运行命令：<code>svnadmin create D:/repository</code>。其中”D:/repository”是要创建的仓库目录名，根据你的要求自己修改。</li>
<li>使用TortoiseSVN的命令：自己新建一个目录，在上面点击右键，TortoiseSVN-&gt;Create Repository-&gt;OK，仓库建好了。</li>
</ul>
</li>
<li>仓库目录说明：<br>打开刚刚建立的仓库目录，你会发现里面有几个目录：<ul>
<li>dav目录是提供给Apache与mod_dav_svn使用的目录，让它们存储内部数据，我之前使用的版本没有这个目录</li>
<li>db目录就是所有版本控制的数据文件</li>
<li>hooks目录放置hook脚本文件的目录</li>
<li>locks用来放置Subversion文件库锁定数据的目录，用来追踪存取文件库的客户端</li>
<li>format文件是一个文本文件，里面只放了一个整数，表示当前文件库配置的版本号</li>
<li>conf目录是这个仓库的配置文件</li>
</ul>
</li>
<li>创建密码：<br>进入conf目录，你会看到三个文件：authz、passwd和svnserve.conf，这些文件就是用来管理svn的登录名和相应的用户分组、密码、权限等功能。以下分别是三个文件的配置方法。<ol>
<li>打开svnserve.conf文件作如下修改，找到以下行：<br><code>#password-db = passwd</code><br>将这三行前的“#”号去掉！</li>
<li>打开passwd文件:<br>在[users]下面增加一行，前面是用户名，后面是密码,如下：<br><code>pedro = 123456</code></li>
<li>关于authz文件，主要是做复杂的群组权限控制，我是单机个人使用，不用设置，只要上面passwd的用户名和密码就可以了</li>
</ol>
</li>
</ol>
<h5 id="测试运行："><a href="#测试运行：" class="headerlink" title="测试运行："></a>测试运行：</h5><ol>
<li>进入Subversion安装目录下的“bin”目录，按住shift键鼠标右键选择“在此处打开命令窗口选项”，输入<code>svnserve -d -r &quot;D:/repository&quot;</code>，此处 “D:/repository” 为仓库所在文件夹，可自行更改。  </li>
<li>在任意目录，右键 TortioseSVN-&gt;Repo broswer-&gt;URL 输入：<code>svn://127.0.0.1</code>如果出现密码提示，那就输入上面设置的用户名和密码。如果在Repository Broswer能看到<code>svn://127.0.0.1</code>，那就说明安装成功，大功告成了。<br><em>注：如为局域网内不同机台测试，可通过更改<code>127.0.0.1</code>为svnserver IP</em></li>
</ol>
<h5 id="创建和使用多个仓库"><a href="#创建和使用多个仓库" class="headerlink" title="创建和使用多个仓库"></a>创建和使用多个仓库</h5><p>使用上面的方法只创建了一个仓库，把所有程序都放入一个仓库看起来有点混乱，我喜欢按照项目给每个项目建立一个仓库，同一个项目的代码组件放入同一个仓库，这样看起来就清爽很多。  </p>
<h6 id="创建多个仓库："><a href="#创建多个仓库：" class="headerlink" title="创建多个仓库："></a>创建多个仓库：</h6><ol>
<li>新建一个放置项目仓库的目录，比如 “D:/repository” 。只是个目录，不要在这个目录创建仓库。</li>
<li>创建项目1的仓库：<code>svnadmin create D:/repository/Project1</code></li>
<li>创建项目2的仓库：<code>svnadmin create D:/repository/Project2</code></li>
<li>依次类推，把每个项目的仓库建立在D:/SVN目录里面就OK了。  </li>
</ol>
<h6 id="使用多个仓库："><a href="#使用多个仓库：" class="headerlink" title="使用多个仓库："></a>使用多个仓库：</h6><ol>
<li>使用 <code>svnserve -d -r &quot;D:/SVN&quot;</code>启动</li>
<li>如果你还是按照<code>svn://127.0.0.1</code>访问仓库就会发现仓库是空的。</li>
<li>要访问你的项目仓库，只要在URL后面加上仓库目录名就可以了，比如可以通过<code>svn://127.0.0.1/Project1</code>来访问项目1的仓库，里面放置的都是项目1相关的代码。用同样的方法就可以把项目仓库分开访问了  </li>
</ol>
<h5 id="将SVN作为服务运行"><a href="#将SVN作为服务运行" class="headerlink" title="将SVN作为服务运行"></a>将SVN作为服务运行</h5><p>如果不把SVN做为service运行，那你每次都要手动启动，并且总是有个命令行的黑窗口在那里。如果你关闭了命令行窗口，那SubVersion也就停止运行了。所以如果你想Windows启动后SVN自动运行，就把它设置为服务把，下面是操作步骤。<br>从命令行进入到SubVersion/bin目录，依次运行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">svnservice -install –daemon –root &quot;D:/repository&quot;</div><div class="line">sc config svnservice start= auto </div><div class="line">net start svnservice</div></pre></td></tr></table></figure></p>
<p>&emsp;<strong><em>特别注意， ‘start’ 后面必须紧跟 ‘=’，不能有空格</em></strong><br>至此，查看Windows的服务，SVNService已经启动，而且是自动运行的服务了。</p>
<h5 id="设置开机自动windows启动服务"><a href="#设置开机自动windows启动服务" class="headerlink" title="设置开机自动windows启动服务"></a>设置开机自动windows启动服务</h5><p>Subversion 从1.4版本开始，可以以windows系统服务的形式在开机时自动运行。但Subversion安装程序还不能把自己安装成windows服务，需要我们自己进行手动安装，方法如下：打开一个DOS命令窗口，执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sc create svnserve binPath= &quot;\&quot;C:/Program Files/Subversion/bin/svnserve.exe\&quot; --service --root e:/svn&quot; displayname= &quot;Subversion Repository&quot; depend= Tcpip start= auto</div></pre></td></tr></table></figure></p>
<p>其中，<code>sc</code>是windows自带的服务配置程序，<br>参数<code>binPath</code>表示svnserve可执行文件的安装路径，由于路径中的”Program Files”带有空格，因此整个路径需要用双引号引起来。而双引号本身是个特殊字符，需要进行转义，因此在路径前后的两个双引号都需要写成<code>\&quot;</code><br><code>--service</code>参数表示以windows服务的形式运行，<br><code>--root</code>指明svn repository的位置，”service”参数与”root”参数都作为binPath的一部分，因此与svnserve.exe的路径一起被包含在一对双引号当中，而这对双引号不需要进行转义。<br><code>displayname</code>表示在windows服务列表中显示的名字，<br><code>depend =Tcpip</code>表示svnserve服务的运行需要tcpip服务，start=auto表示开机后自动运行。<br>安装服务后，svnserve要等<strong>下次开机</strong>时才会自动运行。<br>若要<strong>卸载svn服务</strong>，则执行 <strong><code>sc delete svnserve</code></strong>即可</p>
]]></content>
      
        <categories>
            
            <category> SVN </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SVN </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Xen、OpenVZ、KVM三大VPS技术优劣势详解]]></title>
      <url>/2017/10/08/Xen%E3%80%81OpenVZ%E3%80%81KVM%E4%B8%89%E5%A4%A7VPS%E6%8A%80%E6%9C%AF%E4%BC%98%E5%8A%A3%E5%8A%BF%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h5 id="摘要："><a href="#摘要：" class="headerlink" title="摘要："></a>摘要：</h5><blockquote>
<p>Xen、OpenVZ、KVM三大VPS技术优劣势详解。VPS虚拟服务器是虚拟技术的产品，VPS主机常用的三大虚拟技术分别是Xen、OpenVZ与KVM，很多人都不清楚Xen、OpenVZ、KVM三种技术构建的VPS主机除价格区别外，其他具体有什么区别，这里就简单介绍Xen、OpenVZ、KVM三大VPS虚拟技术并对各自优劣势作详细解说。</p>
</blockquote>
<a id="more"></a>
<h5 id="Xen"><a href="#Xen" class="headerlink" title="Xen"></a>Xen</h5><p>&emsp;&emsp;Xen是半虚拟化技术，它并不是个真正的虚拟机，而是相当于自己运行了个内核的实例，可以自由的加载内核模块，虚拟的内存和IO，稳定而且可预测。分Xen+pv+和Xen+hvm，区别就是pv只支持linux，而hvm支持win系统。</p>
<p>&emsp;&emsp;优势：内存独占，虽然小但是保证分配的到。部分虚拟技术决定了就算是超卖也不会超太离谱。所以般的母鸡就算超了，也很少导致石头盘。当然小鸡有pt就除外了。另外就是即使内存再低也不会当掉，只是会无响应段时间。</p>
<p>&emsp;&emsp;劣势：内存小，硬盘小，带宽小（以上3点均和同价位的openvz对比）。因为没法超卖了，为了赚钱只能把这3个基本配置降下来了。还有就是供应商残次不齐，而且大部分在说xen的时候都木有明说是pv还是hvm，其实pv的性能是优于hvm的。</p>
<h5 id="OpenVZ"><a href="#OpenVZ" class="headerlink" title="OpenVZ"></a>OpenVZ</h5><p>&emsp;&emsp;OpenVZ是操作系统别的虚拟化技术，是底层操作系统上的层应用，这意味着易于理解和低权重开销，般来说也意味着更优的性能。但是OpenVZ配置起来比较灵活，给黑心服务商改低限制的机会。  </p>
<p>&emsp;&emsp;优势：现在外面卖的这种类型，许可的内存都超大，CPU也强劲，而且卖家很多，可比性也很强。性价比超高。<br>　　<br>&emsp;&emsp;劣势：超卖，没有不超卖的，导致各种石头盘，钻石盘。连带的cpu也被过度分割导致性能升值不如其标明的1/10。再有就是内存，基本上OpenVZ技术没有独占的，都是共享，别人多了你就少了，而且这种技术大的劣势就是内存下来后直接就是当机。还有开设vpn各种不方便。
　　</p>
<h5 id="KVM"><a href="#KVM" class="headerlink" title="KVM"></a>KVM</h5><p>　　</p>
<p>&emsp;&emsp;优势：和xen类似，比xen更好的点是，kvm是完全虚拟的，所以不分pv和hvm的区别，所有的kvm类+型的虚拟技术都可以装各种linux的发行版和各种win的发行版，不管供应商在主页有没有写明是否支持win，只要你配置够win运行，那就肯定可以装+的上去，只是方法的问题而已。
　　</p>
<p>&emsp;&emsp;劣势：恰恰因为kvm可以装任意类型的操作系统，导致了折腾帝甚至在128m的机器上装了win2003(上去+后直接所有的cpu和内存都用于硬盘IO 了，不明白这些人想干神马)。其结果就是所有的kvm邻居都得看你周围邻居的脸色。这么说把，一个node下只要有5、6台这种折腾帝，对不起，你的硬盘基本就是石头盘了。
　　</p>
<p>&emsp;&emsp;很多人们都比较倾向于Xen，因为它是对供应商和和客户来说都是可以接受的折衷方案。Openvz成本较高，对于服务商及客户都为不利，而kvmKVM是新兴的虚拟化项目，是是全虚拟化，需要cpu虚拟化指令支持，因此，出售KVM的VPS商家不多，且技术支持和售后服务上也比不上xen的vps主机那么成熟。</p>
]]></content>
      
        <categories>
            
            <category> VPS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> VPS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[How to setup PXE Server for NFS]]></title>
      <url>/2017/08/27/How-to-setup-PXE-Server-for-NFS/</url>
      <content type="html"><![CDATA[<h4 id="原理简介："><a href="#原理简介：" class="headerlink" title="原理简介："></a>原理简介：</h4><ul>
<li>通过PXE网卡启动，</li>
<li>从dhcp服务器获取IP和bootloader,即 pxelinux.0（DHCP server判断是否为合法的来着PXE Client 的请求后）</li>
<li>获取pxelinux.0的参数文件pxelinux.cfg/default</li>
<li>vmlinux、initrd…</li>
</ul>
<h4 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h4><ol>
<li><a href="#1">Server Environment Requirements</a></li>
<li><a href="#2">软件安装，配置PXE Server</a></li>
<li><a href="#3">编译客户端启动内核</a></li>
<li><a href="#4">自定义脚本initial解决系统启动方案</a></li>
<li><a href="#5">启动服务</a></li>
<li><p><a href="#6">运行调试</a></p>
<a id="more"></a>
<h5 id="1-Server-Environment-Requirements"><a href="#1-Server-Environment-Requirements" class="headerlink" title="1. Server Environment Requirements"></a><span id="1">1. Server Environment Requirements</span></h5></li>
<li><p>OS Requirements</p>
<ul>
<li>Redhat 6.3 </li>
<li>Redhat 6.5</li>
<li>newer</li>
</ul>
</li>
<li>Services Requirements<ul>
<li>dhcpd</li>
<li>tftp-server(Tiny FTP)</li>
<li>xinetd</li>
<li>syslinux-tftpboot</li>
</ul>
</li>
</ol>
<h5 id="2-软件安装，配置PXE-Server"><a href="#2-软件安装，配置PXE-Server" class="headerlink" title="2. 软件安装，配置PXE Server"></a><span id="2">2. 软件安装，配置PXE Server</span></h5><ul>
<li>rpm -ivh syslinux-tftpboot-xxx.x86_64.rpm</li>
<li>rpm -ivh xinetd-xxx.x86_64.rpm</li>
<li>rpm -ivh tftp-server-xxx.x86_64.rpm</li>
<li>rpm -ivh dhcp-xxxx.86_64.rpm</li>
</ul>
<p><em>在syslinux-tftpboot 软件包中,只有一个文档是我们需要的,除此之外,其他文档均可删除,这个文档就是/tftpboot/pxelinux.0, support Legacy mode boot</em></p>
<h6 id="配置-DHCP"><a href="#配置-DHCP" class="headerlink" title="配置 DHCP"></a>配置 DHCP</h6><p>在配置 DHCP 之前,首先要确定在 Server 上,需要哪个网卡来受理客户机的请求,这里假设由 eth0的网卡来提供这样的服务,那么就要设定 eth0 的地址为静态 IP,这个网卡配置的文件路径是:<code>/etc/sysconfig/network-scripts/ifcfg-eth0</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cd /etc/sysconfig/network-scripts</div><div class="line">sed -i 's/BOOTPROTO=dhcp/BOOTPROTO=static/g' ifcfg-eth0</div><div class="line">echo "IPADDR=192.168.0.20" &gt;&gt; ifcfg-eth0</div><div class="line">echo "NETMASK=255.255.255.0" &gt;&gt; ifcfg-eth0</div></pre></td></tr></table></figure>
<p>注意:如果有 HWADDR 变量,那是 eth0 的 MAC 地址,这个在读者构建是要注意,不要照抄。设置 PXE Server 名称:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo -ne "192.168.0.20 server server.domain server6 server6.domain6\n" &gt;&gt; /etc/hosts</div></pre></td></tr></table></figure>
<p>DHCP 服务启动之前首先需要一个周期文件/var/lib/dhcpd/dhcpd.leases,如果没有此档就创建之:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">touch /var/lib/dhcpd/dhcpd.leases</div></pre></td></tr></table></figure><br>DHCP 的功能是向客户机分配一个通信 IP,当然是在客户机请求的时候。用 vim 编辑/etc/dhcp/dhcpd.conf,或者按以下命令直接写入该档:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">cat &gt; /etc/dhcp/dhcpd.conf &lt;&lt; "EOF"</div><div class="line">option space PXE;</div><div class="line">option PXE.mtftp-ip                 code 1 = ip-address;</div><div class="line">option PXE.mtftp-cport              code 2 = unsigned integer 16;</div><div class="line">option PXE.mtftp-sport              code 3 = unsigned integer 16;</div><div class="line">option PXE.mtftp-tmout              code 4 = unsigned integer 8;</div><div class="line">option PXE.mtftp-delay              code 5 = unsigned integer 8;</div><div class="line">option PXE.discovery-control        code 6 = unsigned integer 8;</div><div class="line">option PXE.discovery-mcast-addr     code 7 = ip-address;</div><div class="line">option arch                         code 93 = unsigned integer 16;</div><div class="line"></div><div class="line">ddns-update-style interim;</div><div class="line">ignore client-updates;</div><div class="line">allow booting;</div><div class="line">allow bootp;</div><div class="line">subnet 192.168.0.0 netmask 255.255.0.0 &#123;</div><div class="line">DHCPDARGS=eth0;### 指定 eth0 网卡做 DHCP 的服务,其他 PXE Server 网卡不受理客户机的 DHCP 请求。</div><div class="line"></div><div class="line">option routers             192.168.0.1;</div><div class="line">option broadcast-address   192.168.255.255;</div><div class="line">option subnet-mask         255.255.0.0;</div><div class="line">option domain-name-servers 192.168.0.20;</div><div class="line">option nis-domain "domain.org";</div><div class="line">option domain-name "domain.org";</div><div class="line">option time-offset        -18000; # Eastern Standard Time</div><div class="line">range dynamic-bootp       192.168.0.30    192.168.3.252;</div><div class="line">class "pxeclients" &#123;</div><div class="line">match if substring (option vendor-class-identifier,0,9)="PXEClient";</div><div class="line">next-server 192.168.0.20;</div><div class="line">if option arch = 00:07 &#123;</div><div class="line">filename "UEFI/BOOT/BOOTX64.efi";</div><div class="line">&#125; else &#123;</div><div class="line">filename "Legacy/pxelinux.0";</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">default-lease-time 1800;</div><div class="line">max-lease-time 3600;</div><div class="line">&#125;</div><div class="line">EOF</div></pre></td></tr></table></figure></p>
<h6 id="PXE-Server-端配置-TFTP"><a href="#PXE-Server-端配置-TFTP" class="headerlink" title="PXE Server 端配置 TFTP"></a>PXE Server 端配置 TFTP</h6><p>TFTP 在 PXE 远程启动过程中提供档下载的服务,所有的档下载都是通过 TFTP 完成。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">cat &gt; /etc/xinetd.d/tftp &lt;&lt; "EOF"</div><div class="line">service tftp</div><div class="line">&#123;</div><div class="line">socket_type = dgram</div><div class="line">protocols = udp</div><div class="line">wait = yes</div><div class="line">user = root</div><div class="line">server = /usr/sbin/in.tftpd</div><div class="line">server_args = -s /tftpboot -vvv</div><div class="line">disable = no</div><div class="line">per_source = 22</div><div class="line">cps = 100 2</div><div class="line">flags= IPv4</div><div class="line">&#125;</div><div class="line">EOF</div></pre></td></tr></table></figure></p>
<h6 id="构建客户端文件系统"><a href="#构建客户端文件系统" class="headerlink" title="构建客户端文件系统"></a>构建客户端文件系统</h6><p>到这里,建议操作人员自己定制安装一个 Linux 系统,把需要的软件包都装上去,再把安装好的 Linux 系统按照上面的操作去构建一个被挂载文件系统。这样给客户端挂载的文件系统就要小得多。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">mkdir -p /tftpboot/pxeboot/&#123;root,home,var,opt,dev,sys,proc,tmp,mnt,media,misc,net,srv,log&#125;</div><div class="line">mkdir -p /tftpboot/&#123;pxeboot,Legacy,UEFI &#125;</div><div class="line">cd /tftpboot/pxeboot</div><div class="line">chmod 777 tmp</div><div class="line">cp -fr /bin ./</div><div class="line">cp -fr /sbin ./</div><div class="line">cp -fr /usr ./</div><div class="line">cp -fr /etc ./</div><div class="line">cp -fr /lib ./</div><div class="line">cp -fr /lib64 ./</div><div class="line">rm -fr lib/modules/*</div><div class="line">cp -fr /root/.bashrc root/</div><div class="line">cp -fr /root/.bash_profile root/</div><div class="line">if [ -f etc/dhcpd.conf ]; then</div><div class="line">echo "" &gt; etc/dhcpd.conf</div><div class="line">rm etc/grub.conf -fr</div><div class="line">sed -i 's/SELINUX=enforcing/SELINUX=disabled/g' etc/selinux/config</div><div class="line">fi</div><div class="line">sed -i '/\&lt;order\&gt;/D' etc/host.conf</div><div class="line">echo 'reorder on' &gt;&gt; etc/host.conf</div><div class="line">if [ -f etc/xinetd.d/tftp ]; then</div><div class="line">TFTPDIS=`grep "disable" -R etc/xinetd.d/tftp |sed 's/no/yes/g'`</div><div class="line">ORI=`grep "disable" -R etc/xinetd.d/tftp`</div><div class="line">if [[ ! -z $TFTPDIS &amp;&amp; ! -z $ORI ]]; then</div><div class="line">sed -i "s/$ORI/$TFTPDIS/" etc/xinetd.d/tftp</div><div class="line">fi</div><div class="line">fi</div></pre></td></tr></table></figure></p>
<h6 id="准备测试程序包"><a href="#准备测试程序包" class="headerlink" title="准备测试程序包"></a>准备测试程序包</h6><p>程序放到 <code>/tftpboot/pxeboot/usr/local/XXXXXX</code></p>
<h6 id="设置客户机挂载的文件系统"><a href="#设置客户机挂载的文件系统" class="headerlink" title="设置客户机挂载的文件系统"></a>设置客户机挂载的文件系统</h6><p>配置这一项的目的是允许客户机挂载 PXE Server 文件目录,这里允许客户端得到这文件系统的完全控制权。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cat &gt; /etc/exports &lt;&lt; "EOF"</div><div class="line">/tftpboot/pxeboot *(rw,all_squash,anonuid=0,anongid=0)</div><div class="line">EOF</div></pre></td></tr></table></figure></p>
<h6 id="客户机文件系统配置"><a href="#客户机文件系统配置" class="headerlink" title="客户机文件系统配置"></a>客户机文件系统配置</h6><p>客户端启动时对文件系统挂载列表:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">cat &gt; /tftpboot/pxeboot/etc/fstab &lt;&lt; "EOF"</div><div class="line">192.168.0.20:/tftpboot/pxeboot /   nfs  nolock,retry=1            1 1</div><div class="line">tmpfs  /dev/shm           tmpfs     defaults                0 0</div><div class="line">tmpfs  /tmp               tmpfs     defaults                0 0 </div><div class="line">/usr/local/Foxconn               tmpfs     defaults                0 0 </div><div class="line">devpts /dev/pts           devpts    gid=5,mode=620          0 0</div><div class="line">sysfs  /sys               sysfs   defaults                  0 0</div><div class="line">proc   /proc              proc    defaults                  0 0</div><div class="line">EOF</div></pre></td></tr></table></figure></p>
<h6 id="对启动级别和显示终端的设定"><a href="#对启动级别和显示终端的设定" class="headerlink" title="对启动级别和显示终端的设定"></a>对启动级别和显示终端的设定</h6><p>用 vim 编辑<code>/tftpboot/pxeboot/etc/inittab</code>,或者通过以下命令设定启动级别:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -i 's#id:5:initdefault:#id:3:initdefault:#g' /tftpboot/pxeboot/etc/inittab</div></pre></td></tr></table></figure><br>设定后的启动级别是从第 3 级启动,也就是文本模式启动</p>
<h5 id="3-编译客户端启动内核"><a href="#3-编译客户端启动内核" class="headerlink" title="3. 编译客户端启动内核"></a><span id="3">3. 编译客户端启动内核</span></h5><p>编译客户端启动所用的内核,要注意的地方:</p>
<ul>
<li>网络在内核启动过程中的支持</li>
<li>块设备在内核中的支持</li>
<li>支持远程 PXE 启动的网卡驱动不要作为独立的模块编译</li>
<li>网络文件系统的支持</li>
</ul>
<p>以上提到的只是最基本的支持,需要根据自己的需要对内核做实际的配置。<br>内核源代码可以从网页 <a href="http://www.kernel.org/pub/linux/kernel/" target="_blank" rel="external">http://www.kernel.org/pub/linux/kernel/</a> 下载。</p>
<h6 id="解压内核代码包"><a href="#解压内核代码包" class="headerlink" title="解压内核代码包"></a>解压内核代码包</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tar -xzvf linux-3.18.1.tar.gz -C /home</div><div class="line">cd /home</div></pre></td></tr></table></figure>
<h6 id="修改内核版本信息"><a href="#修改内核版本信息" class="headerlink" title="修改内核版本信息"></a>修改内核版本信息</h6><p>给你的 kernel 取个名:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd /home/linux-3.18.1</div><div class="line">EXTVER=`grep '^EXTRAVERSION' -R Makefile`</div><div class="line">sed -i "s/$EXTVER/EXTRAVERSION = -3.18.1 XXX/" Makefile ####可自定义</div></pre></td></tr></table></figure><br>编译内核之前 首先要配置内核 选择需要的模块 按照前面所讲到的顺序我们一步步来配置内核。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make menuconfig</div></pre></td></tr></table></figure></p>
<p>######支持模块自动加载</p>
<pre><code>[*] Enable loadable module support ---&gt;
[*] Forced module loading
[*] Module unloading
[ ] Forced module unloading
[*] Module versioning support
[*] Source checksum for all modules
</code></pre><h6 id="网络在内核启动过程中的支持"><a href="#网络在内核启动过程中的支持" class="headerlink" title="网络在内核启动过程中的支持"></a>网络在内核启动过程中的支持</h6><pre><code>-*- Networking support ---&gt;
Networking options
---&gt;
[*] TCP/IP networking
[*] IP: multicasting
[*] IP: advanced router
[ ] FIB TRIE statistics
[*] IP: policy routing
[*] IP: equal cost multipath
[*] IP: verbose route monitoring
[*]
IP: kernel level autoconfiguration
[*] IP: DHCP support
[*] IP: BOOTP support
[*] IP: RARP support
</code></pre><h6 id="块设备和网卡驱动在内核中的支持"><a href="#块设备和网卡驱动在内核中的支持" class="headerlink" title="块设备和网卡驱动在内核中的支持"></a>块设备和网卡驱动在内核中的支持</h6><pre><code>Device Drivers ---&gt;
[*] Block devices
&lt;*&gt;
---&gt;
RAM block device support
[*] Network device support ---&gt;
[*]
Ethernet (1000 Mbit) ---&gt;
&lt;M&gt; Intel(R) PRO/1000 PCI-Express Gigabit Ethernet support
&lt;*&gt; Intel(R) 82575/82576 PCI-Express Gigabit Ethernet support
</code></pre><p>支持远程 PXE 启动的网卡驱动不要作为独立的模块编译,本文的描述是基于 Intel网卡来实现的,因此,本文在这里只针对 Intel 82575/82576 网卡做了配置。如果你需要对其他网卡驱动设置 你可以找到对于模块选中为“&lt;*&gt;”进行编译</p>
<h6 id="网络文件系统的支持"><a href="#网络文件系统的支持" class="headerlink" title="网络文件系统的支持"></a>网络文件系统的支持</h6><pre><code>File systems ---&gt;
&lt;*&gt; Second extended fs support
...
&lt;*&gt; Ext3 journalling file system support
...
&lt;*&gt; The Extended 4 (ext4) filesystem
...
[*] Network File Systems ---&gt;
&lt;*&gt;
[*]
NFS client support
NFS client support for NFS version 3
[*]
[*]
NFS client support for the NFSv3 ACL protocol extension
NFS client support for NFS version 4
[*]
[*]
NFS client support for NFSv4.1 (EXPERIMENTAL)
Root file system on NFS
...
&lt;*&gt;
NFS server support
[*] Include support for deprecated syscall interface to NFSD
-*- NFS server support for NFS version 3
[*]
[*]
NFS server support for the NFSv3 ACL protocol extension
NFS server support for NFS version 4 (EXPERIMENTAL)
...
&lt;M&gt;
CIFS support (advanced network filesystem, SMBFS successor)
</code></pre><p>对网络文件系统的支持只是文件系统的一部份,不是全部,例如 ext2,ext3 等等文件系统也是要支持的。新编的内核不需要任何虚拟模块的支持,读者可以自行配置启动内核。配置内核完了之后,开始编译内核源代码,这要花些时间。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">make</div><div class="line">make modules</div><div class="line">make modules_install</div><div class="line">make install</div></pre></td></tr></table></figure><br>到这里,最好是重启机器,验证新编译成功的代码是不是能启动。如果能用新的内核启动机器,再将安装的内核拷贝到/tftpboot,将设备驱动目录都拷贝到/tftpboot/pxeboot/lib/modules 目录下。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">d /boot/</div><div class="line">cp -fr</div><div class="line">vmlinuz-3.18.1 /tftpboot</div><div class="line">cd /lib/modules</div><div class="line">cp -fr 3.18.1 /tftpboot/pxeboot/lib/modules</div></pre></td></tr></table></figure></p>
<h5 id="4-自定义脚本initial解决系统启动方案"><a href="#4-自定义脚本initial解决系统启动方案" class="headerlink" title="4. 自定义脚本initial解决系统启动方案"></a><span id="4">4. 自定义脚本initial解决系统启动方案</span></h5><h6 id="Initial-定义"><a href="#Initial-定义" class="headerlink" title="Initial 定义"></a>Initial 定义</h6><p>Linux 系统从 kernel 转向 rc.sysinit 脚本前,我们可以指定自己的初始化脚本 initial,让系统去执行这个脚本。系统在调用 RAMDISK 方案中的 initial 或者调用自定义的 initial 脚本过程是一样的。你可以根据自己的需要去设计这个脚本。这里我们要实现的是将 UUT 客户端的/var 目录建立完善。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">cat &gt; /tftpboot/pxeboot/etc/initial &lt;&lt; "EOF"</div><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line">mount -t tmpfs tmpfs /var</div><div class="line">mkdir -p /var/spool/&#123;anacron,clientmqueue&#125;</div><div class="line">mkdir -p /var/&#123;tmp,log,cache,local,etc&#125;</div><div class="line">mkdir -p /var/log/sa</div><div class="line">mkdir -p /var/lock/subsys</div><div class="line">mkdir -p /var/empty/sshd/etc</div><div class="line">mkdir -p /var/lib/nfs/statd/&#123;sm,sm.bak&#125;</div><div class="line">mkdir -p /var/lib/nfs/rpc_pipefs</div><div class="line">mkdir -p /var/lib/&#123;dbus,rpm&#125;</div><div class="line">- 12 -</div><div class="line">mkdir -p /var/run/&#123;dbus,netreport,udev,systemd,user,mount&#125;</div><div class="line">mkdir -p /var/run/udev/&#123;data,rules.d,links,tags,watch&#125;</div><div class="line">mkdir -p /var/run/systemd/readahead</div><div class="line">mkdir -p /var/spool/&#123;clientmqueue,at&#125;</div><div class="line">touch /var/spool/at/.SEQ</div><div class="line">exec /sbin/init 3</div><div class="line">EOF</div><div class="line">chmod +x /tftpboot/pxeboot/etc/initial</div></pre></td></tr></table></figure></p>
<h6 id="启动文件-bootstrap-配置"><a href="#启动文件-bootstrap-配置" class="headerlink" title="启动文件 bootstrap 配置"></a>启动文件 bootstrap 配置</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">cat &gt; /tftpboot/ Legacy/pxelinux.cfg/default &lt;&lt; "EOF"</div><div class="line">default PXEServer</div><div class="line">prompt 1</div><div class="line">timeout 5</div><div class="line">label PXEServer</div><div class="line">hiddenmenu</div><div class="line">title PXE Diagnostics Linux x86_x64</div><div class="line">kernel vmlinuz-3.18.1</div><div class="line">append init=/etc/initial lang=en_US keymap=us root=/dev/nfs nfsroot=192.168.0.20:/tftpboot/pxeboot/ ip=dhcp </div><div class="line">EOF</div></pre></td></tr></table></figure>
<h5 id="5-启动服务"><a href="#5-启动服务" class="headerlink" title="5. 启动服务"></a><span id="5">5. 启动服务</span></h5><p>运行<code>setup</code>命令关掉防火墙和SeLinux：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@pxeserver ~]# setup</div><div class="line">选中Firewall configuration，选中Run Tool，回车确认；</div><div class="line">Security Level: ( ) Enabled(*) Disabled</div><div class="line">SELinux: Enforcing</div><div class="line">Permissive</div><div class="line">Disabled</div></pre></td></tr></table></figure><br>启动服务进程:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">service iptables stop</div><div class="line">service dhcpd restart</div><div class="line">service nfs restart</div><div class="line">service xinetd restart</div></pre></td></tr></table></figure></p>
<h5 id="6-运行调试"><a href="#6-运行调试" class="headerlink" title="6. 运行调试"></a><span id="6">6. 运行调试</span></h5><ol>
<li>插入键盘鼠标会弹出设备的输入输出msg信息<br>可以设定printk级别到最高忽略这些信息<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo -n 0 0 0 0 &gt; /proc/sys/kernel/printk</div></pre></td></tr></table></figure></li>
<li>客户端获取不到 IP<ul>
<li>检查 DHCP 服务是否已经开启(service dhcpd status)。</li>
<li>检查网络情况,可以将第三方计算机与 server 主机相连,试着去获取 IP,如果得不到 IP,DHCP server出了问题;如果可以获得 IP,网络有问题;如果有部分客户端分到 IP,部分没分到 IP,可能是 IP POOL中的 IP 已经耗尽,这是最好清理一下 DHCP 日志,然后再重启 DHCP:<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rm -fr /var/lib/dhcpd/dhcpd.leases~</div><div class="line">echo &gt; /var/lib/dhcpd/dhcpd.leases</div><div class="line">service dhcpd restart</div></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> PXEServer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于Mongodb的WechatRobot群聊记录功能]]></title>
      <url>/2017/07/30/%E5%9F%BA%E4%BA%8EMongodb%E7%9A%84WechatRobot%E7%BE%A4%E8%81%8A%E8%AE%B0%E5%BD%95%E5%8A%9F%E8%83%BD/</url>
      <content type="html"><![CDATA[<h4 id="基于Mongodb的WechatRobot群聊记录功能"><a href="#基于Mongodb的WechatRobot群聊记录功能" class="headerlink" title="基于Mongodb的WechatRobot群聊记录功能"></a>基于Mongodb的WechatRobot群聊记录功能</h4><blockquote>
<p>实验目的：实现类似下图效果的微信签到，群聊数据记录功能</p>
</blockquote>
<img src="/2017/07/30/基于Mongodb的WechatRobot群聊记录功能/result.jpg" alt="result image" title="result image">
<h5 id="开发步骤："><a href="#开发步骤：" class="headerlink" title="开发步骤："></a>开发步骤：</h5><pre><code>1. Mongodb数据库搭建
2. 插入、查询命令测试
3. 功能函数编写和测试
4. 主函数调用效果监测
</code></pre><a id="more"></a>
<h5 id="Mongodb数据库搭建"><a href="#Mongodb数据库搭建" class="headerlink" title="Mongodb数据库搭建"></a>Mongodb数据库搭建</h5><p>&#160; &#160; &#160; &#160;Mongodb基础搭建和使用教程可以点击<a href="https://www.runoob.com/mongodb/mongodb-tutorial.html" target="_blank" rel="external">菜鸟教程</a>（没收广告费）进行学习，教程内容通俗易懂老少咸宜，适合初学者学习（真没有收广告费）╮(╯▽╰)╭</p>
<h5 id="插入、查询命令测试"><a href="#插入、查询命令测试" class="headerlink" title="插入、查询命令测试"></a>插入、查询命令测试</h5><p>&#160; &#160; &#160; &#160;关于群签到和聊天数据统计功能会用到的基础命令有</p>
<ol>
<li><code>db.xxx.save</code></li>
<li><code>db.xxx.update</code></li>
<li><code>db.xxx.find</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&gt; show dbs</div><div class="line">admin   0.078GB</div><div class="line">local   0.078GB</div><div class="line">nodedb  0.078GB</div><div class="line">test    0.078GB</div><div class="line">wechat  0.078GB</div><div class="line">&gt; use test</div><div class="line">switched to db test</div><div class="line">&gt; db.wechat.save(&#123;&quot;name&quot;:&quot;Pedro&quot;,&quot;group&quot;:&quot;group1&quot;,&quot;number&quot;:1&#125;)</div><div class="line">WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)</div><div class="line">&gt; db.wechat.save(&#123;&quot;name&quot;:&quot;Qiqi&quot;,&quot;group&quot;:&quot;group1&quot;,&quot;number&quot;:2&#125;)</div><div class="line">WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)</div><div class="line">&gt; db.wechat.find(&#123;&quot;group&quot;:&quot;group1&quot;&#125;)</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;597e066d4b3188da1b178cd0&quot;), &quot;name&quot; : &quot;Pedro&quot;, &quot;group&quot; : &quot;group1&quot;, &quot;number&quot; : 1 &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;597e06854b3188da1b178cd1&quot;), &quot;name&quot; : &quot;Qiqi&quot;, &quot;group&quot; : &quot;group1&quot;, &quot;number&quot; : 2 &#125;</div><div class="line">&gt; db.wechat.update(&#123;&quot;name&quot;:&quot;Pedro&quot;&#125;,&#123; &quot;$inc&quot; : &#123;&quot;number&quot;:1&#125;&#125;)</div><div class="line">WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;)</div><div class="line">&gt; db.wechat.find(&#123;&quot;name&quot;:&quot;Pedro&quot;&#125;)</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;597e066d4b3188da1b178cd0&quot;), &quot;name&quot; : &quot;Pedro&quot;, &quot;group&quot; : &quot;group1&quot;, &quot;number&quot; : 2 &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>也许你会纠结为什么此处使用<code>save</code>而非<code>insert</code>，其实两者在此处并没有区别，可以通用。关于两者的细微区别在此稍作介绍：<br>   <a href="http://blog.csdn.net/xiaojin21cen/article/details/40480609" target="_blank" rel="external"><strong>若新增的数据中存在主键 ，insert() 会提示错误，而save() 则更改原来的内容为新内容</strong>。</a>如：已存在数据：  <code>{_id : 1, &quot; name &quot; : &quot; n1 &quot; }</code>，再次进行插入操作时，<br><code>insert({_id : 1, &quot; name &quot; : &quot; n2 &quot; })</code>    会报主键重复的错误提示<br><code>save({ _id : 1, &quot; name &quot; : &quot; n2 &quot; })</code>    会把 n1 修改为  n2  。</p>
</blockquote>
<h5 id="功能函数编写和测试"><a href="#功能函数编写和测试" class="headerlink" title="功能函数编写和测试"></a>功能函数编写和测试</h5><ol>
<li>关于签到功能设计，需要确定要插入数据库的数据格式，根据与群签到相关的数据，可以设计数据的内容包括：<strong>用户名、群名称、个人签到总次数、签到日期（貌似非必须）</strong>，即：<code>{&quot;name&quot;:name,&quot;group&quot;:group,&quot;time&quot;:1,&quot;date&quot;:datetime.datetime.now().strftime(&#39;%b-%d-%y&#39;)}</code></li>
<li>由于要实现图中“第n个签到”的功能，还需要新建一条数据用来存储当日已签到总人数，其内容包括：<strong>特殊数据标记（用于区分一个collection下此数据与其他数据区别，便于查找），群名称，群签到总次数，日期</strong>，即：<code>{&quot;daily_report&quot;:&quot;Yes&quot;,&quot;date&quot;:datetime.datetime.now().strftime(&#39;%b-%d-%y&#39;),&quot;number&quot;:1,&quot;group&quot;:group}</code></li>
<li>当日发言总数的数据结构相对比较简单：<strong>特殊数据标记，群名称，日期，总发言数</strong>，即<code>{&quot;daily_Sum&quot;:&quot;Yes&quot;,&quot;date&quot;:datetime.datetime.now().strftime(&#39;%b-%d-%y&#39;),&quot;today&quot;:1,&quot;group&quot;:group}</code></li>
<li>关于当日发言数排行的实现，首先需要记录个人在单个群组的聊天次数，此时需要的数据结构为：<strong>特殊数据标记，日期，发言数，群名称，用户名</strong>，即<code>{&quot;per_daily&quot;:&quot;Yes&quot;,&quot;date&quot;:datetime.datetime.now().strftime(&#39;%b-%d-%y&#39;),&quot;number&quot;:1,&quot;group&quot;:group,&quot;name&quot;:name}</code></li>
<li>实现了数据采集，最后要做的就是数据的分析和排序，在本例的源码的<code>listGroup</code>函数中使用了<code>find</code>的<code>limit</code>、<code>sort</code>方法实现：<code>perlogs.find({&quot;date&quot;:date,&quot;group&quot;:group}).limit(5).sort([(&quot;number&quot;,-1)])</code></li>
<li>最后在我们的robot中的群组消息处理函数处调用这个模块的函数就可以了，大功告成！</li>
</ol>
<blockquote>
<p>附上文中所提及函数的部分源码，完整源码已更新到<a href="https://github.com/pedroqin/wechat_robot" target="_blank" rel="external">我的GitHub</a>中，有兴趣的请<a href="https://github.com/pedroqin/wechat_robot" target="_blank" rel="external">点击跳转</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment">#coding:utf-8</span></div><div class="line"></div><div class="line"><span class="comment"># sign in num , return :your signIn number and total signIn number</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">signIn</span><span class="params">(name,group)</span>:</span></div><div class="line">    string=posts.find_one(&#123;<span class="string">"name"</span>:name,<span class="string">"group"</span>:group&#125;)</div><div class="line"><span class="comment">#    print "+++",string,"+++"</span></div><div class="line">    <span class="keyword">if</span>  string  != <span class="keyword">None</span>:</div><div class="line">        <span class="keyword">if</span> string[<span class="string">"date"</span>] != datetime.datetime.now().strftime(<span class="string">'%b-%d-%y'</span>):</div><div class="line">             posts.update(&#123;<span class="string">"name"</span>:name,<span class="string">"group"</span>:group&#125;,&#123; <span class="string">"$set"</span> : &#123;<span class="string">"date"</span>:datetime.datetime.now().strftime(<span class="string">'%b-%d-%y'</span>)&#125;&#125;,<span class="keyword">True</span>,<span class="keyword">False</span>)</div><div class="line">             posts.update(&#123;<span class="string">"name"</span>:name,<span class="string">"group"</span>:group&#125;,&#123; <span class="string">"$inc"</span> : &#123;<span class="string">"time"</span>: <span class="number">1</span>&#125;&#125;,<span class="keyword">True</span>,<span class="keyword">False</span>)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">             <span class="keyword">return</span> <span class="string">"False"</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        new_post=&#123;<span class="string">"name"</span>:name,<span class="string">"group"</span>:group,<span class="string">"time"</span>:<span class="number">1</span>,<span class="string">"date"</span>:datetime.datetime.now().strftime(<span class="string">'%b-%d-%y'</span>)&#125;</div><div class="line">        posts.save(new_post)</div><div class="line">    <span class="keyword">return</span> [posts.find_one(&#123;<span class="string">"name"</span>:name,<span class="string">"group"</span>:group&#125;)[<span class="string">"time"</span>],daily(group)]</div><div class="line"><span class="comment">#</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">daily</span><span class="params">(group)</span>:</span></div><div class="line">    number=glogs.find_one(&#123;<span class="string">"daily_report"</span>:<span class="string">"Yes"</span>,<span class="string">"group"</span>:group,<span class="string">"date"</span>:datetime.datetime.now().strftime(<span class="string">'%b-%d-%y'</span>)&#125;)</div><div class="line">    <span class="keyword">if</span> number == <span class="keyword">None</span>:</div><div class="line">        new=&#123;<span class="string">"daily_report"</span>:<span class="string">"Yes"</span>,<span class="string">"date"</span>:datetime.datetime.now().strftime(<span class="string">'%b-%d-%y'</span>),<span class="string">"number"</span>:<span class="number">1</span>,<span class="string">"group"</span>:group&#125;</div><div class="line">        glogs.save(new)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        glogs.update(&#123;<span class="string">"daily_report"</span>:<span class="string">"Yes"</span>,<span class="string">"group"</span>:group,<span class="string">"date"</span>:datetime.datetime.now().strftime(<span class="string">'%b-%d-%y'</span>)&#125;,&#123; <span class="string">'$inc'</span> :&#123;<span class="string">"number"</span>: <span class="number">1</span>&#125;&#125;)</div><div class="line">    <span class="keyword">return</span> glogs.find_one(&#123;<span class="string">"daily_report"</span>:<span class="string">"Yes"</span>,<span class="string">"group"</span>:group,<span class="string">"date"</span>:datetime.datetime.now().strftime(<span class="string">'%b-%d-%y'</span>)&#125;)[<span class="string">"number"</span>]</div><div class="line"></div><div class="line"><span class="comment">#return today Msg total num, and accumulate today Msg num</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">dailyLogMsg</span><span class="params">(group)</span>:</span></div><div class="line">    allMsg=glogs.find_one(&#123;<span class="string">"daily_Sum"</span>:<span class="string">"Yes"</span>,<span class="string">"group"</span>:group,<span class="string">"date"</span>:datetime.datetime.now().strftime(<span class="string">'%b-%d-%y'</span>)&#125;)</div><div class="line">    <span class="keyword">if</span> allMsg == <span class="keyword">None</span>:<span class="comment"># create today's log</span></div><div class="line">        new=&#123;<span class="string">"daily_Sum"</span>:<span class="string">"Yes"</span>,<span class="string">"date"</span>:datetime.datetime.now().strftime(<span class="string">'%b-%d-%y'</span>),<span class="string">"today"</span>:<span class="number">1</span>,<span class="string">"group"</span>:group&#125;</div><div class="line">        glogs.save(new)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        glogs.update(&#123;<span class="string">"daily_Sum"</span>:<span class="string">"Yes"</span>,<span class="string">"group"</span>:group,<span class="string">"date"</span>:datetime.datetime.now().strftime(<span class="string">'%b-%d-%y'</span>)&#125;,&#123; <span class="string">'$inc'</span> :&#123;<span class="string">"today"</span>: <span class="number">1</span>&#125;&#125;)</div><div class="line">    <span class="keyword">return</span> glogs.find_one(&#123;<span class="string">"daily_Sum"</span>:<span class="string">"Yes"</span>,<span class="string">"group"</span>:group,<span class="string">"date"</span>:datetime.datetime.now().strftime(<span class="string">'%b-%d-%y'</span>)&#125;)[<span class="string">"today"</span>]<span class="comment">#return today 's sum for create the picture</span></div><div class="line"></div><div class="line"><span class="comment">#accumulate everyone's total Msg num</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">perNum</span><span class="params">(name,group)</span>:</span></div><div class="line">    perNum=perlogs.find_one(&#123;<span class="string">"per_daily"</span>:<span class="string">"Yes"</span>,<span class="string">"name"</span>:name,<span class="string">"group"</span>:group,<span class="string">"date"</span>:datetime.datetime.now().strftime(<span class="string">'%b-%d-%y'</span>)&#125;)</div><div class="line">    <span class="keyword">if</span> perNum == <span class="keyword">None</span>:</div><div class="line">        new=&#123;<span class="string">"per_daily"</span>:<span class="string">"Yes"</span>,<span class="string">"date"</span>:datetime.datetime.now().strftime(<span class="string">'%b-%d-%y'</span>),<span class="string">"number"</span>:<span class="number">1</span>,<span class="string">"group"</span>:group,<span class="string">"name"</span>:name&#125;</div><div class="line">        perlogs.save(new)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        perlogs.update(&#123;<span class="string">"per_daily"</span>:<span class="string">"Yes"</span>,<span class="string">"group"</span>:group,<span class="string">"name"</span>:name,<span class="string">"date"</span>:datetime.datetime.now().strftime(<span class="string">'%b-%d-%y'</span>)&#125;,&#123; <span class="string">'$inc'</span> :&#123;<span class="string">"number"</span>: <span class="number">1</span>&#125;&#125;)</div><div class="line">    <span class="keyword">return</span> perlogs.find_one(&#123;<span class="string">"per_daily"</span>:<span class="string">"Yes"</span>,<span class="string">"name"</span>:name,<span class="string">"group"</span>:group,<span class="string">"date"</span>:datetime.datetime.now().strftime(<span class="string">'%b-%d-%y'</span>)&#125;)[<span class="string">"number"</span>]</div><div class="line"></div><div class="line"><span class="comment">#list top 5 people who had sent most msg yesterday</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">listGroup</span><span class="params">(date,group)</span>:</span></div><div class="line">    result=perlogs.find(&#123;<span class="string">"date"</span>:date,<span class="string">"group"</span>:group&#125;).limit(<span class="number">5</span>).sort([(<span class="string">"number"</span>,<span class="number">-1</span>)])</div><div class="line">    <span class="keyword">return</span> result</div><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Wechat </tag>
            
            <tag> Python2.6 </tag>
            
            <tag> Mongodb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Wechat_linux_Shell]]></title>
      <url>/2017/07/26/Wechat_linux_Shell/</url>
      <content type="html"><![CDATA[<h4 id="做這些實驗的初衷"><a href="#做這些實驗的初衷" class="headerlink" title="做這些實驗的初衷"></a>做這些實驗的初衷</h4><p>&#160; &#160; &#160; &#160;樹莓派自從買回來已經吃灰半年有餘，正巧最近在看python，本著練手的初衷開始對樹莓派進行“廢物利用”，下面開始正題~</p>
<hr>
<h6 id="本實驗主要指導來自於知乎這篇文當：当Python遇上微信，可以这么玩"><a href="#本實驗主要指導來自於知乎這篇文當：当Python遇上微信，可以这么玩" class="headerlink" title="本實驗主要指導來自於知乎這篇文當：当Python遇上微信，可以这么玩"></a>本實驗主要指導來自於知乎這篇文當：<a href="https://zhuanlan.zhihu.com/p/26514576" target="_blank" rel="external">当Python遇上微信，可以这么玩</a></h6><a id="more"></a>
<h4 id="實驗環境"><a href="#實驗環境" class="headerlink" title="實驗環境:"></a>實驗環境:</h4><blockquote>
<p>Respberry Pi + python</p>
<h4 id="摘要："><a href="#摘要：" class="headerlink" title="摘要："></a>摘要：</h4><p>基於python下itchat庫實現Wechat robot,用python修飾器對robot回復功能進行消息判斷和消息處理，實現對Respberry發送命令以及接收命令運行結果</p>
</blockquote>
<h4 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h4><ol>
<li>環境架設</li>
</ol>
<p>&#160; &#160; &#160; &#160;本文主要測試是基於RespberryPi下Ubuntu16.4，當然你可以在在虛擬機以及電腦的linux系統上進行。Python版本是2.6，暫時沒有測試3.0版本。另外需<code>pip install itchat</code>或者<a href="https://github.com/littlecodersh/ItChat/tree/robot" target="_blank" rel="external">點這裡</a>下載itchat后解壓<code>python setup.py install</code> 導入</p>
<ol>
<li><p>Wechat robot</p>
<ol>
<li>既然是Wechat robot，那就加個簡單的對話功能，實現人機對話，此處實驗採用的是圖靈機器人，大家可以<a href="http://www.tuling123.com/" target="_blank" rel="external">點擊這裡</a>進行賬號註冊,<a href="http://www.tuling123.com/help/help_center.jhtml?nav=doc" target="_blank" rel="external">點擊查看幫助文檔</a>。基礎的機器人服務是免費的。通過得到的key值，將本地的微信消息與圖靈連通，實現機器人模擬會話。</li>
<li>基於前一條功能，最基本的Wechat Robot已經完成，接下來要完成的就是做一個基於robot的類似簡版<a href="https://baike.baidu.com/item/Xshell/5659054?fr=aladdin" target="_blank" rel="external">Xshell</a>工具，可以通過微信發送命令到robot所在系統并執行，實現對linux主機的簡易控制。所以，本功能的實現主體是，將微信接收到的命令通過python調用相應函數實現命令的執行，並接受返回值等信息。在本案例中選用commands的子進程函數getstatusoutput()函數實現，并且帶有返回值以及返回信息。</li>
<li>後續開發中，會通過itchat包中對發送接收信息的支持，可以實現發送接收文件到linux主機。 </li>
</ol>
</li>
</ol>
<h5 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h5><blockquote>
<p>基於itchat實現的Wechat robot 本質上為網頁版微信，登錄方式等與網頁版微信一致</p>
</blockquote>
<h5 id="附簡易代碼做參考"><a href="#附簡易代碼做參考" class="headerlink" title="附簡易代碼做參考"></a>附簡易代碼做參考</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> itchat</div><div class="line"><span class="keyword">import</span> requests</div><div class="line"><span class="keyword">import</span> commands</div><div class="line"><span class="keyword">from</span> itchat.content <span class="keyword">import</span> *</div><div class="line"></div><div class="line">KEY = <span class="string">'6d1f45613b434325b1b823f19fca5a91'</span></div><div class="line"><span class="comment">#this is the tuling robot,get the wechat msg you received,and send you the response</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_response</span><span class="params">(msg)</span>:</span></div><div class="line">    apiUrl = <span class="string">'http://www.tuling123.com/openapi/api'</span></div><div class="line">    data = &#123;</div><div class="line">        <span class="string">'key'</span>    : KEY,</div><div class="line">        <span class="string">'info'</span>   : msg,</div><div class="line">        <span class="string">'userid'</span> : <span class="string">'Pedro-wechat-robot'</span>,</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        r = requests.post(apiUrl, data=data).json()</div><div class="line">        <span class="keyword">return</span> r.get(<span class="string">'text'</span>)</div><div class="line">    <span class="keyword">except</span>:</div><div class="line">        <span class="keyword">return</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@itchat.msg_register(itchat.content.TEXT)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">tuling_reply</span><span class="params">(msg)</span>:</span></div><div class="line"><span class="comment">#用以區分普通消息與command，已*開頭為commands</span></div><div class="line">    <span class="keyword">if</span> msg[<span class="string">'Text'</span>].startswith(<span class="string">'*'</span>):</div><div class="line">        (status_cmd,output_cmd) = commands.getstatusoutput(msg[<span class="string">'Text'</span>][<span class="number">1</span>:])</div><div class="line">	</div><div class="line">        <span class="keyword">return</span> <span class="string">u'return : '</span>+str(status_cmd)+<span class="string">u'\nresult : \n'</span> + str(output_cmd)</div><div class="line"></div><div class="line"><span class="comment">######### reply in normal #######</span></div><div class="line">    defaultReply = <span class="string">'I received: '</span> + msg[<span class="string">'Text'</span>]</div><div class="line"><span class="comment">######### reply by tuling #######</span></div><div class="line">    reply = get_response(msg[<span class="string">'Text'</span>])</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> reply <span class="keyword">or</span> defaultReply</div><div class="line"></div><div class="line">itchat.auto_login(hotReload=<span class="keyword">True</span>) </div><div class="line">itchat.run()</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Wechat </tag>
            
            <tag> Python2.6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[my_first_Markdown_Blog]]></title>
      <url>/2017/05/23/my-first-markdown-blog/</url>
      <content type="html"><![CDATA[<p>title: my_first_Markdown_Blog<br>date: 2017-05-23 01:01:31<br>categories: personal<br>tags:</p>
<h2 id="随想"><a href="#随想" class="headerlink" title="- 随想 "></a>- 随想 </h2><h3 id="个人感想"><a href="#个人感想" class="headerlink" title="个人感想"></a>个人感想</h3><h4 id="分享小故事"><a href="#分享小故事" class="headerlink" title="分享小故事"></a>分享小故事</h4><p>工作6个月左右的时候听到一个有趣的小故事<br><a id="more"></a></p>
<blockquote>
<p>镇上有一个富人，有一天听闻大城市回来一位在全国有名的大餐厅工作了好多年厨师，便高薪聘请做自己的私人厨师。富人按市里的规格给厨师配置了一套完整的厨房设施，然后让厨师给按市里的菜谱做菜。一眨眼俩小时上来一桌子菜，老板迫不及待拿起筷子尝了起来，刚吃第一口，眉头一皱，接着尝第二个，第三个。。。<br>老板不解的把厨师叫出来问：你这菜怎么做的，怎么这么难吃，不是大城市里大餐馆的厨师么，怎么做饭做的不如我的乡下厨师呢还</p>
<p>答：我在市里餐馆的时候是给餐馆大厨打下手的，从来没做过饭</p>
<p>问：打下手也不至于做的这么难吃吧，打下手都干什么呢</p>
<p>答：剥洋葱，这些年一直在剥洋葱</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>毕业一年多，也进入公司工作了一年，很庆幸刚毕业就有能进大公司工作，这里的工作环境，福利待遇，对一个刚毕业的本科生来说都是很友好的。这一年里，我迅速的学习掌握工作技能，以尽快的掌握和胜任工作的内容。</p>
<p>进步不止一点半点。所谓的进步不止在<code>linux</code>,<code>服务器</code>相关知识的学习和应用，更重要的是对工作的整体认识和把握，以及处理工作中各类问题的应变力和控制力。最最最重要的是对自己职业规划的探索和认识。</p>
<p>以前常常听到一种说法</p>
<blockquote>
<p>你毕业以后从事方向很有可能成为你未来事业发展方向</p>
</blockquote>
<p>姑且不论其是否正确，单对个人来说还是有其道理的，从毕业前大三大四实习到毕业后选择的职业方向，从最开始的不自信和探索，到对职业方向和自己的认同，逐步确立起了自己的发展方向。<strong>这无疑是我一年来最大的收获</strong></p>
<h4 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h4><p>对自己的发展方向有了初步认识以后，接下来就是向发展方向努力进步了。都说<em>刚毕业的前几年最应该努力学习</em>这一点不假，身边的人有的在考验有的在考证，无疑是为了将来有更好的出路。反倒自己浑浑噩噩了大半年，学习效率低下，实在是惭愧。</p>
<p>参加工作这一年多里，Team来来走走差不多换了一拨人，其中有一个前辈的话深深警醒着我。我问他来了这么久进步大么。他回答说<em>刚来的一年里学的东西多，进步挺大的，后来就是带案子做案子，也没有什么进步</em>，这不是在说以后的我么，我现在的菜鸟水平不就是那个刚学会剥洋葱的人（连洋葱还没有剥熟练），所以，<strong>努力学习寻求更大的发展空间才是硬道理啊！！！</strong></p>
<h5 id="但是，让我先把洋葱剥熟练了吧！！！"><a href="#但是，让我先把洋葱剥熟练了吧！！！" class="headerlink" title="但是，让我先把洋葱剥熟练了吧！！！"></a>但是，让我先把洋葱剥熟练了吧！！！</h5><p><a href="constmyheart@163.com">email to me</a></p>
<p><img src="http://i1.piimg.com/1949/414797c82b962f42.jpg" width="200" hight="200"></p>
]]></content>
      
        <categories>
            
            <category> personal </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 随想 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
