<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Linux性能评估]]></title>
      <url>/2017/12/17/Linux%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0/</url>
      <content type="html"><![CDATA[<blockquote>
<p>之前在产品测试中遇到产品server上传log、过站 Fail 等问题，在排错过程中耽误不少时间，故在此做总结已做备用。另：其中使用命令只是演示用，抛砖引玉，更多功能请自行探索  </p>
</blockquote>
<p><strong>主要命令：iostat free sar pidstat vmstat netstat mtr traceroute</strong><br><a id="more"></a></p>
<p> <strong>综述</strong>：<br> top命令为较综合命令，可先通过top查看系统资源，后再选择不同命令进行细节观察。pidstat主要用于监控全部或指定进程占用系统资源情况。sar 和iostat相比，都有平均值计算，sar输出有百分制，更加直观。mtr动态跟踪网络路由，相比traceroute更加可靠。</p>
<h4 id="一、-CPU-篇"><a href="#一、-CPU-篇" class="headerlink" title="一、 CPU 篇"></a>一、 CPU 篇</h4><h5 id="1-1-查看cpu信息"><a href="#1-1-查看cpu信息" class="headerlink" title="1.1 查看cpu信息"></a>1.1 查看cpu信息</h5><p>通过如下命令获取cpu信息，如：cpu数（physical id +1 ）、cpu核数（cpu cores ）等<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">cat /proc/cpuinfo</div><div class="line">...</div><div class="line">processor       : 3</div><div class="line">vendor_id       : GenuineIntel</div><div class="line">cpu family      : 6</div><div class="line">model           : 26</div><div class="line">model name      : Intel(R) Xeon(R) CPU           L5520  @ 2.27GHz</div><div class="line">stepping        : 5</div><div class="line">cpu MHz         : 2260.381</div><div class="line">cache size      : 8192 KB</div><div class="line">physical id     : 0</div><div class="line">siblings        : 4</div><div class="line">core id         : 3</div><div class="line">cpu cores       : 4</div><div class="line">apicid          : 3</div><div class="line">initial apicid  : 3</div><div class="line">fpu             : yes</div><div class="line">fpu_exception   : yes</div><div class="line">cpuid level     : 11</div><div class="line">wp              : yes</div><div class="line">flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov onstant_tsc rep_good unfair_spinlock pni ssse3 cx16 sse4_1 sse4_2 popcnt hypervi</div><div class="line">bogomips        : 4520.76</div><div class="line">clflush size    : 64</div><div class="line">cache_alignment : 64</div><div class="line">address sizes   : 40 bits physical, 48 bits virtual</div><div class="line">power management:</div></pre></td></tr></table></figure><br>通过结果可知：我的 Hyper-V 中Server 用的CPU为L5520，没有开启超线程，4核4线程，一颗CPU，所以CPU是4核的.</p>
<h5 id="1-2-vmstat"><a href="#1-2-vmstat" class="headerlink" title="1.2 vmstat"></a>1.2 vmstat</h5><p><code>vmstat 3</code>：(每3秒输出一次)<br><code>vmstat 3 5</code>：(每3秒输出一次，输出5次)<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[root@Centos ~]# vmstat  3 5</div><div class="line">procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----</div><div class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</div><div class="line"> 0  0      0 7317072  27040 685444    0    0    28    43 1017   24  0  0 99  0  0</div><div class="line"> 0  0      0 7317056  27040 685444    0    0     0     0 4007   54  0  0 100  0  0</div><div class="line"> 0  0      0 7317048  27040 685444    0    0     0     0 4005   53  0  0 100  0  0</div><div class="line"> 0  0      0 7317048  27040 685444    0    0     0     0 4001   50  0  0 100  0  0</div><div class="line"> 0  0      0 7317056  27040 685444    0    0     0     0 4024   52  0  0 100  0  0</div><div class="line"></div></pre></td></tr></table></figure><br>结果解析：</p>
<ul>
<li><p><code>r</code>表示运行队列(就是说多少个进程真的分配到CPU)，我测试的服务器目前CPU比较空闲，没什么程序在跑，当这个值超过了CPU核数，就会出现CPU瓶颈了。如果运行队列过大，表示你的CPU很繁忙，一般会造成CPU使用率很高。</p>
</li>
<li><p><code>b</code> 表示阻塞的进程,进程阻塞。</p>
</li>
<li><p><code>swpd</code> 虚拟内存已使用的大小，如果大于0，表示你的机器物理内存不足了，如果不是程序内存泄露的原因，那么你该升级内存了或者把耗内存的任务迁移到其他机器。</p>
</li>
<li><p><code>free</code>   空闲的物理内存的大小，我的机器内存总共8G，剩余7G多。</p>
</li>
<li><p><code>buff</code>   <strong>Linux/Unix系统是用来存储，目录里面有什么内容，权限等的缓存</strong>，我本机占用不到300M</p>
</li>
<li><p><code>cache</code> <strong>cache直接用来记忆我们打开的文件,给文件做缓冲</strong>，我本机大概占用600多M(把空闲的物理内存的一部分拿来做文件和目录的缓存，是为了提高 程序执行的性能，当程序使用内存时，buffer/cached会很快地被使用。)</p>
</li>
<li><p><code>si</code>  每秒从磁盘读入虚拟内存的大小，如果这个值大于0，表示物理内存不够用或者内存泄露了，要查找耗内存进程解决掉。我的机器内存充裕，一切正常。</p>
</li>
<li><p><code>so</code>  每秒虚拟内存写入磁盘的大小，如果这个值大于0，同上。</p>
</li>
<li><p><code>bi</code>  块设备每秒接收的块数量，这里的块设备是指系统上所有的磁盘和其他块设备，默认块大小是1024byte，我本机上没什么IO操作，所以一直是0。</p>
</li>
<li><p><code>bo</code> 块设备每秒发送的块数量，例如我们读取文件，bo就要大于0。bi和bo一般都要接近0，不然就是IO过于频繁，需要调整。</p>
</li>
<li><p><code>in</code> 每秒CPU的中断次数，包括时间中断。</p>
</li>
<li><p><code>cs</code> 每秒上下文切换次数，例如我们调用系统函数，就要进行上下文切换，线程的切换，也要进程上下文切换，这个值要越小越好，太大了，要考虑调低线程或者进程的数目,例如在apache和nginx这种web服务器中，我们一般做性能测试时会进行几千并发甚至几万并发的测试，选择web服务器的进程可以由进程或者线程的峰值一直下调，压测，直到cs到一个比较小的值，这个进程和线程数就是比较合适的值了。系统调用也是，每次调用系统函数，我们的代码就会进入内核空间，导致上下文切换，这个是很耗资源，也要尽量避免频繁调用系统函数。上下文切换次数过多表示你的CPU大部分浪费在上下文切换，导致CPU干正经事的时间少了，CPU没有充分利用，是不可取的。</p>
</li>
<li><p><code>us</code> 用户CPU时间。</p>
</li>
<li><p><code>sy</code> 系统CPU时间，如果太高，表示系统调用时间长，例如是IO操作频繁。</p>
</li>
<li><p><code>id</code> 空闲 CPU时间，一般来说，id + us + sy = 100,id是空闲CPU占比，us是用户CPU使用占比，sy是系统CPU使用占比。</p>
</li>
<li><p><code>wt</code> 等待IO CPU时间。</p>
</li>
</ul>
<p>若“us”+“sy”值，较大，说明CPU负载较大。<br>若“wa”较大，说明IO存在比较严重的等待，需查看是否是磁盘大量的读写IO导致，可通过更快的磁盘（SSD）或者磁盘调优（raid）尝试改进</p>
<h5 id="1-3-iostat-c"><a href="#1-3-iostat-c" class="headerlink" title="1.3 iostat -c"></a>1.3 iostat -c</h5><p><code>iostat</code>命令需要安装“sysstat”包，非系统自带<br><code>iostat -c/m/d</code> ： 查看CPU/Mem/HDD使用情况<br><code>iostat -c/m/d 2 3</code>： 每隔2秒查看CPU/Mem/HDD使用情况，共查看3次<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[root@Centos ~]# iostat -c 2 3</div><div class="line">Linux 2.6.32-431.el6.x86_64 (Centos)    12/17/2017      _x86_64_        (4 CPU)</div><div class="line"></div><div class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</div><div class="line">           0.22    0.00    0.11    0.16    0.00   99.51</div><div class="line"></div><div class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</div><div class="line">           0.00    0.00    0.00    0.00    0.00  100.00</div><div class="line"></div><div class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</div><div class="line">           0.00    0.00    0.13    0.00    0.00   99.87</div></pre></td></tr></table></figure></p>
<ul>
<li>%user: 在用户级别运行所使用的CPU的百分比.</li>
<li>%nice: 运行正常进程所使用的CPU的百分比.</li>
<li>%sys: 在系统级别(kernel)运行所使用CPU的百分比.</li>
<li>%iowait: CPU等待硬件I/O时,所占用CPU百分比.</li>
<li>%idle: CPU空闲时间的百分比.</li>
</ul>
<h5 id="1-4-uptime"><a href="#1-4-uptime" class="headerlink" title="1.4 uptime"></a>1.4 uptime</h5><p><code>uptime</code>同<code>top</code>命令第一行<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@Centos ~]# uptime</div><div class="line"> 14:02:46 up  1:15,  7 users,  load average: 0.00, 0.00, 0.00</div></pre></td></tr></table></figure><br>load average : 1分钟负载状态  5分钟负载状态 15分钟负载状态<br>可以通过<code>cat /proc/loadavg</code>获得</p>
<h4 id="二、-内存篇"><a href="#二、-内存篇" class="headerlink" title="二、 内存篇"></a>二、 内存篇</h4><h5 id="2-1-free"><a href="#2-1-free" class="headerlink" title="2.1 free"></a>2.1 free</h5><p><code>free -m</code>:以“MB”为单位显示<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[root@Centos ~]# free</div><div class="line">             total       used       free     shared    buffers     cached</div><div class="line">Mem:       8184092     868136    7315956          0      27400     685528</div><div class="line">-/+ buffers/cache:     155208    8028884</div><div class="line">Swap:      4194296          0    4194296</div><div class="line">[root@Centos ~]# free -m</div><div class="line">             total       used       free     shared    buffers     cached</div><div class="line">Mem:          7992        847       7144          0         26        669</div><div class="line">-/+ buffers/cache:        151       7840</div><div class="line">Swap:         4095          0       4095</div></pre></td></tr></table></figure><br>关于 cache：<br>linux的内存管理机制与windows的内存管理机制不同，就个人理解，linux遵循<strong>最大使用内存</strong>的原则，所有打开的文件都会被缓存，在文件打开关闭之后，缓存文件的内存不会从物理内存中释放（会有其他机制做限制，控制使用内存大小）。但是windows会在文件关闭以后释放内存。所以在此，<strong>空闲内存应为“-/+ buffers/cache:  ”所在行中“free”列,即，物理内存中”free”+”cache”</strong><br>关于 Swap:<br>当 Swap 行中 used 列数值较大，应考虑增加物理内存</p>
<h5 id="2-2-sar、pidstat"><a href="#2-2-sar、pidstat" class="headerlink" title="2.2 sar、pidstat"></a>2.2 sar、pidstat</h5><p><code>sar/pidstat -r/-u/-d  3 5</code>[获取内存/CPU/磁盘,3s 统计一次，统计5次]<br><code>sar -u 3</code> 获取cpu3秒内状态<br><code>pidstat  -r -p 1 3</code>（获取1进程每隔3秒状态）<br><code>sar</code>和<code>pidstat</code> 所显示结果有平均值统计<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[root@Centos ~]# sar -r 3 5</div><div class="line">Linux 2.6.32-431.el6.x86_64 (Centos)    12/17/2017      _x86_64_        (4 CPU)</div><div class="line"></div><div class="line">02:32:00 PM kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit</div><div class="line">02:32:03 PM   7313692    870400     10.64     27720    687340    127776      1.03</div><div class="line">02:32:06 PM   7313692    870400     10.64     27720    687340    127776      1.03</div><div class="line">02:32:09 PM   7313692    870400     10.64     27720    687340    127776      1.03</div><div class="line">02:32:12 PM   7313700    870392     10.64     27720    687340    127776      1.03</div><div class="line">02:32:15 PM   7313692    870400     10.64     27720    687340    127776      1.03</div><div class="line">Average:      7313694    870398     10.64     27720    687340    127776      1.03</div></pre></td></tr></table></figure></p>
<ul>
<li>kbmemfree:这个值和free命令中的free值基本一致,所以它不包括buffer和cache的空间.</li>
<li>kbmemused:这个值和free命令中的used值基本一致,所以它包括buffer和cache的空间.</li>
<li>%memused:这个值是kbmemused和内存总量(不包括swap)的一个百分比.</li>
<li>kbbuffers和kbcached:这两个值就是free命令中的buffer和cache.</li>
<li>kbcommit:保证当前系统所需要的内存,即为了确保不溢出而需要的内存(RAM+swap).</li>
<li>%commit:这个值是kbcommit与内存总量(包括swap)的一个百分比.  </li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[root@Centos ~]# pidstat -r -p 1824 3 4</div><div class="line">Linux 2.6.32-431.el6.x86_64 (Centos)    12/17/2017      _x86_64_        (4 CPU)</div><div class="line"></div><div class="line">02:45:12 PM       PID  minflt/s  majflt/s     VSZ    RSS   %MEM  Command</div><div class="line">02:45:15 PM      1824      0.00      0.00   57676   2308   0.03  sftp-server</div><div class="line">02:45:18 PM      1824      0.00      0.00   57676   2308   0.03  sftp-server</div><div class="line">02:45:21 PM      1824      0.00      0.00   57676   2308   0.03  sftp-server</div><div class="line">02:45:24 PM      1824      0.00      0.00   57676   2308   0.03  sftp-server</div><div class="line">Average:         1824      0.00      0.00   57676   2308   0.03  sftp-server</div></pre></td></tr></table></figure>
<ul>
<li>minflt/s: 每秒次缺页错误次数(minor page faults)，次缺页错误次数意即虚拟内存地址映射成物理内存地址产生的page fault次数</li>
<li>majflt/s: 每秒主缺页错误次数(major page faults)，当虚拟内存地址映射成物理内存地址时，相应的page在swap中，这样的page fault为major page fault，一般在内存使用紧张时产生</li>
<li><strong>VSZ:      该进程使用的虚拟内存(以kB为单位)</strong></li>
<li><strong>RSS:      该进程使用的物理内存(以kB为单位)</strong></li>
<li><strong>%MEM:     该进程使用内存的百分比</strong></li>
<li>Command:  拉起进程对应的命令  </li>
</ul>
<p>主要关注字体加粗部分</p>
<h4 id="三、-磁盘篇"><a href="#三、-磁盘篇" class="headerlink" title="三、 磁盘篇"></a>三、 磁盘篇</h4><h5 id="3-1-iostat-d"><a href="#3-1-iostat-d" class="headerlink" title="3.1 iostat -d"></a>3.1 iostat -d</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[root@Centos ~]# iostat -d 2 3</div><div class="line">Linux 2.6.32-431.el6.x86_64 (Centos)    12/17/2017      _x86_64_        (4 CPU)</div><div class="line"></div><div class="line">Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn</div><div class="line">scd0              0.01         0.05         0.00        360          0</div><div class="line">sda               1.79        73.26       114.68     569936     892194</div><div class="line"></div><div class="line">Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn</div><div class="line">scd0              0.00         0.00         0.00          0          0</div><div class="line">sda               0.00         0.00         0.00          0          0</div><div class="line"></div><div class="line">Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn</div><div class="line">scd0              0.00         0.00         0.00          0          0</div><div class="line">sda               0.00         0.00         0.00          0          0</div></pre></td></tr></table></figure>  
<ul>
<li>tps: 每秒钟发送到的I/O请求数.</li>
<li>Blk_read /s: 每秒读取的block数.</li>
<li>Blk_wrtn/s: 每秒写入的block数.</li>
<li>Blk_read:   读入的block总数.</li>
<li>Blk_wrtn:  写入的block总数.<h5 id="3-2-pidstat-d"><a href="#3-2-pidstat-d" class="headerlink" title="3.2 pidstat -d"></a>3.2 pidstat -d</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[root@Centos ~]# pidstat -d -p 1824 3 4</div><div class="line">Linux 2.6.32-431.el6.x86_64 (Centos)    12/17/2017      _x86_64_        (4 CPU)</div><div class="line"></div><div class="line">03:00:41 PM       PID   kB_rd/s   kB_wr/s kB_ccwr/s  Command</div><div class="line">03:00:44 PM      1824      0.00      0.00      0.00  sftp-server</div><div class="line">03:00:47 PM      1824      0.00      0.00      0.00  sftp-server</div><div class="line">03:00:50 PM      1824      0.00      0.00      0.00  sftp-server</div><div class="line">03:00:53 PM      1824      0.00      0.00      0.00  sftp-server</div><div class="line">Average:         1824      0.00      0.00      0.00  sftp-server</div></pre></td></tr></table></figure></li>
<li>kB_rd/s: 每秒进程从磁盘读取的数据量(以kB为单位)</li>
<li>kB_wr/s: 每秒进程向磁盘写的数据量(以kB为单位)</li>
<li>kB_ccwr/s: 该进程每秒取消磁盘写入的数量(以kB为单位)</li>
<li>Command: 拉起进程对应的命令<h5 id="3-3-sar-d"><a href="#3-3-sar-d" class="headerlink" title="3.3 sar -d"></a>3.3 sar -d</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">[root@Centos ~]# sar -d 2 3</div><div class="line">Linux 2.6.32-431.el6.x86_64 (Centos)    12/17/2017      _x86_64_        (4 CPU)</div><div class="line"></div><div class="line">03:04:00 PM       DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util</div><div class="line">03:04:02 PM   dev11-0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</div><div class="line">03:04:02 PM    dev8-0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</div><div class="line"></div><div class="line">03:04:02 PM       DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util</div><div class="line">03:04:04 PM   dev11-0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</div><div class="line">03:04:04 PM    dev8-0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</div><div class="line"></div><div class="line">03:04:04 PM       DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util</div><div class="line">03:04:06 PM   dev11-0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</div><div class="line">03:04:06 PM    dev8-0      1.51      0.00     12.06      8.00      0.01      6.67      4.33      0.65</div><div class="line"></div><div class="line">Average:          DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util</div><div class="line">Average:      dev11-0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</div><div class="line">Average:       dev8-0      0.50      0.00      4.01      8.00      0.00      6.67      4.33      0.22</div></pre></td></tr></table></figure></li>
<li>DEV            磁盘设备</li>
<li>用参数-p可以打印出sda,hdc等磁盘设备名称,如果不用参数-p,设备节点则有可能是dev8-0,dev22-0</li>
<li>tps:每秒从物理磁盘I/O的次数.多个逻辑请求会被合并为一个I/O磁盘请求,一次传输的大小是不确定的.</li>
<li>rd_sec/s:每秒读扇区的次数.</li>
<li>wr_sec/s:每秒写扇区的次数.</li>
<li>avgrq-sz:平均每次设备I/O操作的数据大小(扇区).</li>
<li>avgqu-sz:磁盘请求队列的平均长度.</li>
<li>await:从请求磁盘操作到系统完成处理,每次请求的平均消耗时间,包括请求队列等待时间,单位是毫秒(1秒=1000毫秒).</li>
<li>svctm:系统处理每次请求的平均时间,不包括在请求队列中消耗的时间.</li>
<li>%util:I/O请求占CPU的百分比,比率越大,说明越饱  </li>
</ul>
<h4 id="四、-网络篇"><a href="#四、-网络篇" class="headerlink" title="四、 网络篇"></a>四、 网络篇</h4><h5 id="4-1-ping"><a href="#4-1-ping" class="headerlink" title="4.1 ping"></a>4.1 ping</h5><h5 id="4-2-netstat"><a href="#4-2-netstat" class="headerlink" title="4.2 netstat"></a>4.2 netstat</h5><p><code>netstat -r</code>:路由统计<br><code>netstat -i</code>:网卡流量统计<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[root@Centos ~]# netstat -r</div><div class="line">Kernel IP routing table</div><div class="line">Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface</div><div class="line">192.168.0.0     *               255.255.255.0   U         0 0          0 eth0</div><div class="line">link-local      *               255.255.0.0     U         0 0          0 eth0</div><div class="line">default         192.168.0.1     0.0.0.0         UG        0 0          0 eth0</div><div class="line">[root@Centos ~]# netstat -i</div><div class="line">Kernel Interface table</div><div class="line">Iface       MTU Met    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg</div><div class="line">eth0       1500   0    66277      0      0      0    34173      0      0      0 BMRU</div><div class="line">lo        16436   0        0      0      0      0        0      0      0      0 LRU</div></pre></td></tr></table></figure>  </p>
<ul>
<li>Iface 网络接口名称。</li>
<li>MTU（Maximum Trasmission Unit，最大传输单元）。链路层具有最大传输单元MTU这个特性，它限制了数据帧的最大长度，不同的网络类型都有一个上限值。以太网的MTU是1500，你可以用 netstat -i命令查看这个值。如果IP层有数据包要传，而且数据包的长度超过了MTU，那么IP层就要对数据包进行分片（fragmentation）操作，使每一片的长度都小于或等于MTU。我们假设要传输一个UDP数据包，以太网的MTU为1500字节，一般IP首部为20字节，UDP首部为8字节，数据的净荷（payload）部分预留是1500-20-8=1472字节。如果数据部分大于1472字节，就会出现分片现象。</li>
<li>Met（Metric，度量值）。（供某些操作系统用，用于计算一条路由的成本）</li>
<li>RX-OK 接收时，正确的数据包数。</li>
<li>RX-ERR 接收时，产生错误的数据包数。</li>
<li>RX-DRP 接收时，丢弃的数据包数。</li>
<li>RX-OVR 接收时，由于过速（在数据传输中，由于接收设备不能接收按照发送速率传送来的数据而使数据丢失）而丢失的数据包数。</li>
<li>TX-OK 发送时，正确的数据包数。</li>
<li>TX-ERR 发送时，产生错误的数据包数。</li>
<li>TX-DRP 发送时，丢弃的数据包数。</li>
<li>TX-OVR 发送时，由于过速而丢失的数据包数。</li>
<li>Flg 标志。<ul>
<li>B 已经设置了一个广播地址。</li>
<li>L 该接口是一个回送设备。</li>
<li>M 接收所有数据包（混乱模式）。</li>
<li>N 避免跟踪。</li>
<li>O 在该接口上，禁用ARP。</li>
<li>P 这是一个点到点链接。</li>
<li>R 接口正在运行。</li>
<li>U 接口处于“活动”状态。</li>
</ul>
</li>
</ul>
<h5 id="4-3-mtr-traceroute"><a href="#4-3-mtr-traceroute" class="headerlink" title="4.3 mtr/traceroute"></a>4.3 mtr/traceroute</h5><p><code>mtr www.baidu.com</code> :动态跟踪网络路由状态</p>
<p><code>traceroute www.baidu.com</code> :静态跟踪网络路由状态</p>
<h4 id="五、-系统性能分析标准"><a href="#五、-系统性能分析标准" class="headerlink" title="五、 系统性能分析标准"></a>五、 系统性能分析标准</h4><p>此处借鉴一张运维的系统性能分析标准做参考</p>
<img src="/2017/12/17/Linux性能评估/standard.jpg" alt="系统性能分析标准" title="系统性能分析标准">   
<h4 id="六、-参考文档"><a href="#六、-参考文档" class="headerlink" title="六、 参考文档"></a>六、 参考文档</h4><ul>
<li><a href="http://blog.csdn.net/atomicfox/article/details/6756687" target="_blank" rel="external">netstat -i 和ifconfig -s的输出解释</a></li>
<li><a href="https://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316661.html" target="_blank" rel="external">Linux netstat命令详解</a></li>
<li><a href="http://blog.csdn.net/jiangguilong2000/article/details/12535395" target="_blank" rel="external">Linux 运行进程实时监控pidstat命令详解</a></li>
<li><a href="http://blog.csdn.net/chuanzhongdu1/article/details/46357505" target="_blank" rel="external">pidstat详解</a></li>
<li><a href="http://blog.csdn.net/colin_liu2009/article/details/6862910" target="_blank" rel="external">SAR命令的解析及使用</a></li>
<li><a href="http://blog.csdn.net/zhangjay/article/details/6656771" target="_blank" rel="external">iostat命令详解</a></li>
<li><a href="https://www.cnblogs.com/ggjucheng/archive/2012/01/05/2312625.html" target="_blank" rel="external">inux vmstat命令实战详解</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux性能 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux shell 算数运算/字符串操作总结]]></title>
      <url>/2017/12/05/linux-shell-%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<blockquote>
<p>最近在开发脚本工具时遇到不少对字符串/数字进行运算的问题，一通google/baidu 后，捎带做一下总结，以便以后使用。主要包含<code>expr</code>、<code>bc</code>、[]、(())、<strong>正则表达式</strong>之<code>grep</code>、<code>sed</code>、<code>awk</code></p>
</blockquote>
<a id="more"></a>
<h3 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h3><h4 id="1-expr"><a href="#1-expr" class="headerlink" title="1. expr"></a>1. expr</h4><p>expr在使用中要注意一些书写，如表达式中<font color="#DC143C">变量和运算符号之间的空格及一些运算符号需要转义，还有一点需要记住，expr只适用于整数之间的运算！</font></p>
<h5 id="1-1-表达式："><a href="#1-1-表达式：" class="headerlink" title="1.1 表达式："></a>1.1 表达式：</h5><p>  expr的help文档中关于表达式部分如下：</p>
<pre><code>ARG1 | ARG2       若ARG1 的值不为0 或者为空，则返回ARG1，否则返回ARG2

ARG1 &amp; ARG2       若两边的值都不为0 或为空，则返回ARG1，否则返回 0

ARG1 &lt; ARG2       ARG1 小于ARG2
ARG1 &lt;= ARG2      ARG1 小于或等于ARG2
ARG1 = ARG2       ARG1 等于ARG2
ARG1 != ARG2      ARG1 不等于ARG2
ARG1 &gt;= ARG2      ARG1 大于或等于ARG2
ARG1 &gt; ARG2       ARG1 大于ARG2

ARG1 + ARG2       计算 ARG1 与ARG2 相加之和
ARG1 - ARG2       计算 ARG1 与ARG2 相减之差

ARG1 * ARG2       计算 ARG1 与ARG2 相乘之积
ARG1 / ARG2       计算 ARG1 与ARG2 相除之商
ARG1 % ARG2       计算 ARG1 与ARG2 相除之余数
</code></pre><p>示例：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@rhat650 ~]# expr 1 + 2 - 3 \* 4 / 5 + 1</div><div class="line">2</div></pre></td></tr></table></figure><br>通过结果相信你已知道expr的计算规律，它与我们日常所理解的数学表达式一样，括号的优先级最高，然后是“*”、“/”，而且每个数或符号都需要用空格分隔，结果也是整数。</p>
<h5 id="1-2-字符串"><a href="#1-2-字符串" class="headerlink" title="1.2 字符串"></a>1.2 字符串</h5><pre><code>match 字符串 表达式等于&quot;字符串 :表达式&quot;
substr 字符串 偏移量 长度替换字符串的子串，偏移的数值从 1 起计
index 字符串 字符在字符串中发现字符的地方建立下标，或者标0
length 字符串字符串的长度
</code></pre><ol>
<li><p>match<br>expr中的<code>expr match $string substring</code>命令在string字符串中匹配substring字符串（substring字符串可以是正则表达式），然后返回匹配到的substring字符串的长度，若找不到则返回0。<br>示例：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@rhat650 ~]# str="123 hello wrold 456"</div><div class="line">[root@rhat650 ~]# expr match "$str" .*w</div><div class="line">11</div></pre></td></tr></table></figure>  
<p>.*5匹配了6个字符。</p>
</li>
<li><p>substr<br>在shell中可以用{string:position}和{string:position:length}进行对string字符串中字符的抽取。第一种是从position位置开始抽取直到字符串结束，第二种是从position位置开始抽取长度为length的子串。而用expr中的<code>expr substr stringposition $length</code>同样能实现上述功能。<br>实例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@rhat650 ~]# str="123 hello wrold 456"</div><div class="line">[root@rhat650 ~]# echo $&#123;str:5&#125;</div><div class="line">ello wrold 456</div><div class="line">[root@rhat650 ~]# echo $&#123;str:5:3&#125;</div><div class="line">ell</div><div class="line">[root@rhat650 ~]# expr substr "$str" 5 3</div><div class="line">hel</div></pre></td></tr></table></figure>  
<p>从中可以看出{string:position}和{string:position:length}从0开始计数，而expr substr stringposition $length从1开始。</p>
</li>
<li><p>index<br>expr中的<code>expr index string substring</code>索引命令功能在字符串string上找出substring中字符第一次出现的位置，若找不到则expr index返回0。注意它匹配的是字符而非字符串。<br>实例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@rhat650 ~]# str="123 hello wrold 456"</div><div class="line">[root@rhat650 ~]# expr index "$str" c</div><div class="line">0</div><div class="line">[root@rhat650 ~]# expr index "$str" o</div><div class="line">9</div></pre></td></tr></table></figure></li>
<li>length<br>计算字符串的长度。  <img src="/2017/12/05/linux-shell-算数运算-字符串操作总结/str_length.jpg" alt="str_length.jpg" title="">   
</li>
</ol>
<h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><p><code>let arg [arg ...]</code> #arg代表运算式</p>
<h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h5><p>自加操作:  <code>let no++</code><br>自减操作:  <code>let no--</code><br>简写形式:  <code>let no+=10</code>，<code>let no-=20</code>，分别等同于 <code>et no=no+10</code>，<code>let no=no-20</code></p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash let </div><div class="line">a=5+4 b=9-3 </div><div class="line">echo $a $b</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash let </div><div class="line">"t1 = ((a = 5 + 3, b = 7 - 1, c = 15 - 4))" </div><div class="line">echo "t1 = $t1, a = $a, b = $b"</div></pre></td></tr></table></figure>
<h4 id="bc"><a href="#bc" class="headerlink" title="bc"></a>bc</h4><p>bc是一种任意精度的计算语言，注意是一种语言，它提供了一些语法结构，比如条件判断、循环等，可以说是很强大的，但是我在实际中还没有找到需要这个用途的场合 。另外一个用途就是用来进行进制转换。</p>
<p>上面我们介绍的expr之支持整数运算，但对于浮点运算就无能为力了，而且expr不能进行指数运算，而都有bc这些都不再话下。</p>
<h5 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h5><p>我们先来了解几个有用的参数：</p>
<pre><code>-i 强制交互模式；

-l 使用bc的内置库，bc里有一些数学库，对三角计算等非常实用；

-q 进入bc交互模式时不再输出版本等多余的信息。
</code></pre><h5 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h5><p>ibase，obase 用于<font color="#DC143C">进制转换</font>，ibase是输入的进制，obase是输出的进制，默认是十进制；</p>
<p>scale 小数保留位数，默认保留0位。</p>
<h5 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h5><p>在shell命令行直接输入bc及能进入bc语言的交互模式。</p>
<h5 id="非交互模式"><a href="#非交互模式" class="headerlink" title="非交互模式"></a>非交互模式</h5><p>bc也可以进行非交互式的运算，方法是与echo一起使用。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@rhat650 ~]# echo "scale=3;1+2-3+5/3^2"|bc  //*优先级^ &gt; *、/ &gt; +、- */</div><div class="line">.555</div><div class="line">[root@rhat650 ~]# echo "scale=3;1+1+2-3+5/3^2"|bc</div><div class="line">1.555</div></pre></td></tr></table></figure></p>
<h4 id="amp"><a href="#amp" class="headerlink" title="(()) &amp; []"></a>(()) &amp; []</h4><p>这两个在shell中比较常见，这两个和expr命令有些类似，也是用于整数计算。<br>他们支持的运算符号有如下：</p>
<pre><code>|    位或
+ ||   若前后两者都不为0，则返回1，否则返回0
 &amp;  位与
+ &amp;&amp;  若前者为0，不再对后者进行处理，否则对后者处理，后者不为0时返回1
 &lt; 
 &lt;=
 ==
 !=
 &gt;=
 &gt; 
 + 
 - 
 * 
 / 
 %
</code></pre><p>带+号的两个运算符其实是shell支持的运算符。</p>
<p>这两个对与expr的优点是：运算符号全部不需要转义。</p>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@rhat650 ~]# echo $((2+5))</div><div class="line">7</div><div class="line">[root@rhat650 ~]# echo $((2%5))</div><div class="line">2</div><div class="line">[root@rhat650 ~]# echo $[2*5]</div><div class="line">10</div></pre></td></tr></table></figure>
<h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p> 传统的 grep 程序, 在没有参数的情况下, 只输出符合 RE 字符串之句子.</p>
<h5 id="常见参数"><a href="#常见参数" class="headerlink" title="常见参数"></a>常见参数</h5><pre><code>-v: 逆反模示, 只输出&quot;不含&quot; RE 字符串之句子.
-r: 递归模式, 可同时处理所有层级子目录里的文件.
-q: 静默模式, 不输出任何结果(stderr 除外. 常用以获取 return value, 符合为 true, 否则为false .)
-i: 忽略大小写.
-w: 整词比对, 类似 &lt;word&gt; .
-n: 同时输出行号.
-c: 只输出符合比对的行数.
-l: 只输出符合比对的文件名称.
-o: 只输出符合 RE 的字符串. (gnu 新版独有, 不见得所有版本都支持.)
-E: 切换为 egrep .  
</code></pre><h5 id="正则总结"><a href="#正则总结" class="headerlink" title="正则总结"></a>正则总结</h5><pre><code>^word     表示带搜寻的字符串(word)在行首
word$     表示带搜寻的字符串(word)在行尾
.         表示1个任意字符
\         表示转义字符，在特殊字符前加\会将原本的特殊字符意义去除
*         表示重复0到无穷多个前一个RE(正则表达式)字符
[list]    表示搜索含有list的字符串
[n1-n2]   表示搜索指定的字符串范围,例如[0-9] [a-z] [A-Z]等
[^list]   表示反向字符串的范围,例如[0-9]表示非数字字符，[A-Z]表示非大写字符范围
\{n,m\}   表示找出n到m个前一个RE字符
\{n,\}    表示n个以上的前一个RE字符
</code></pre><h4 id="egrep"><a href="#egrep" class="headerlink" title="egrep"></a>egrep</h4><p>为 grep 的扩充版本, 改良了许多传统 grep 不能或不便的操作. 比方说:</p>
<ul>
<li>grep 之下不支持 ? 与 + 这两种 modifier, 但 egrep 则可.</li>
<li>grep 不支持 a|b 或 (abc|xyz) 这类”或一”比对, 但 egrep 则可.</li>
<li>grep 在处理 {n,m} 时, 需用 { 与 } 处理, 但 egrep 则不需.  </li>
</ul>
<h5 id="egrep-grep-E正则总结"><a href="#egrep-grep-E正则总结" class="headerlink" title="egrep/grep -E正则总结:"></a>egrep/grep -E正则总结:</h5><pre><code>+    表示重复一个或一个以上的前一个RE字符
范例:egrep &apos;go+d&apos; test.txt
表示搜寻(god)(good)(goood)...等等字符串，o+代表[一个以上的o]  
?    表示重复零个或一个的前一个RE字符
范例:egrep &apos;go?d&apos; test.txt
表示搜寻(gd)(god)字符串，o?代表[空的或1个o]
注:egrep下&apos;go+d&apos;和&apos;go?d&apos;的结果集合就等于grep下的&apos;go*d&apos;
|    表示用或(or)的方式找出数个字符串
范例:egrep &apos;gd|good|dog&apos; test.txt
表示搜寻(gd)或(god)或(god)字符串，|代表或
()    表示找出群组字符串
范例:egrep &apos;g(la|oo)d&apos; test.txt
表示搜寻(glad)或(good)字符串
()    +表示找出多个重复群组的判别
范例: echo &apos;AxyzxyzxyzxyzxyzC&apos;|egrep &apos;A(xyz)+C&apos;
表示搜寻开头是A结尾是C，中间有一个以上的&apos;xyz&apos;字符串
</code></pre><h4 id="fgrep"><a href="#fgrep" class="headerlink" title="fgrep"></a>fgrep</h4><p> 不作 RE 处理, 表达式仅作一般字符串处理, 所有 meta 均失去功能.</p>
<h4 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h4><p> 获取ip<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ifconfig eth0 |grep 'inet addr'</div></pre></td></tr></table></figure><br>将IP前面的部分予以删除<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ifconfig eth0 |grep 'inet addr'| sed 's/^.*addr://g'</div></pre></td></tr></table></figure><br>将IP后面的部分删除<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ifconfig eth0 |grep 'inet addr'| sed 's/^.*addr://g'| sed 's/Bcast:.*$//g'</div></pre></td></tr></table></figure><br>示例：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">root@RaspberryPi:~# ifconfig wlan0|grep 'inet addr'</div><div class="line">          inet addr:192.168.0.156  Bcast:192.168.0.255  Mask:255.255.255.0</div><div class="line">root@RaspberryPi:~# ifconfig wlan0|grep 'inet addr'|sed 's/^.*addr://g'</div><div class="line">192.168.0.156  Bcast:192.168.0.255  Mask:255.255.255.0</div><div class="line">root@RaspberryPi:~# ifconfig wlan0|grep 'inet addr'|sed 's/^.*addr://g'|sed 's/Bcast.*$//g'</div><div class="line">192.168.0.156</div><div class="line">root@RaspberryPi:~# ifconfig wlan0|sed -rn 's#^.*dr:(.*)B.*$#\1#gp'</div><div class="line">192.168.0.156</div><div class="line">root@RaspberryPi:~# ifconfig wlan0|awk -F '[ :]+' 'NR==2 &#123;print $4&#125;'</div><div class="line">192.168.0.156</div></pre></td></tr></table></figure></p>
<h4 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h4><h5 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h5><p>用last取出登陆数据前五行<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">root@RaspberryPi:~# last -n 5</div><div class="line">root     pts/0        192.168.0.110    Wed Dec  6 00:13   still logged in</div><div class="line">reboot   system boot  4.1.19-v7+       Thu Jan  1 08:00   still running</div><div class="line">root     pts/0        192.168.0.110    Mon Dec  4 23:19 - down  (1+00:53)</div><div class="line">reboot   system boot  4.1.19-v7+       Thu Jan  1 08:00 - 00:12 (17505+16:11)</div><div class="line">root     pts/0        192.168.0.110    Mon Dec  4 22:33 - crash (-17504+-14:-33)</div><div class="line"></div><div class="line">wtmp begins Mon Dec  4 21:49:01 2017</div></pre></td></tr></table></figure><br>取出账号与登陆者IP，且账号与IP之间以TAB隔开<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">root@RaspberryPi:~# last -n 5 |awk '&#123;print $1 "\t" $3&#125;'</div><div class="line">root    192.168.0.110</div><div class="line">reboot  boot</div><div class="line">root    192.168.0.110</div><div class="line">reboot  boot</div><div class="line">root    192.168.0.110</div><div class="line"></div><div class="line">wtmp    Mon</div></pre></td></tr></table></figure><br>注:$1代表用空格或TAB隔开的第一个字段，以此类推。。<br>  $0代表该行全部字段<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">root@RaspberryPi:~#  last -n 5 |awk '&#123;print $1 "\t lines:" NR "\t columes:" NF&#125;'</div><div class="line">root     lines:1         columes:10</div><div class="line">reboot   lines:2         columes:10</div><div class="line">root     lines:3         columes:10</div><div class="line">reboot   lines:4         columes:11</div><div class="line">root     lines:5         columes:10</div><div class="line">         lines:6         columes:0</div><div class="line">wtmp     lines:7         columes:7</div></pre></td></tr></table></figure><br>注: NF代表每一行的$0的字段总数<br>   NR代表目前awk所处的是第几行数据<br>   FS代表目标分隔符，默认为空格  </p>
<h5 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h5><p>在/etc/passwd中以:来作为分段字符，则我们要查阅第三栏小于10以下的数据，并只列出账号与第三栏<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">root@RaspberryPi:~# cat /etc/passwd | awk '&#123;FS=":"&#125; $3&lt;10 &#123;print $1 "\t \t"$3&#125;'</div><div class="line">root:x:0:0:root:/root:/bin/bash</div><div class="line">daemon          1</div><div class="line">bin             2</div><div class="line">sys             3</div><div class="line">sync            4</div><div class="line">games           5</div><div class="line">man             6</div><div class="line">lp              7</div><div class="line">mail            8</div><div class="line">news            9</div></pre></td></tr></table></figure><br>注：查询结果未显示第一行数据，是因为我们虽然定义了FS=”:” 但却只能在第二行生效<br>想读取第一行就需要BEGIN这个关键词:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">root@RaspberryPi:~# cat /etc/passwd | awk 'BEGIN &#123;FS=":"&#125; $3&lt;10 &#123;print $1 "\t \t"$3&#125;'</div><div class="line">root            0</div><div class="line">daemon          1</div><div class="line">bin             2</div><div class="line">sys             3</div><div class="line">sync            4</div><div class="line">games           5</div><div class="line">man             6</div><div class="line">lp              7</div><div class="line">mail            8</div><div class="line">news            9</div></pre></td></tr></table></figure></p>
<h5 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h5><p>统计TCP连接状态<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root@RaspberryPi:~#  netstat -na | awk '/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;'</div><div class="line">LISTEN 15</div><div class="line">ESTABLISHED 2</div></pre></td></tr></table></figure><br><code>/^tcp/</code><br>过滤出以tcp开头的行，“^”为正则表达式用法，以…开头，这里是过滤出以tcp开头的行。<br><code>S[]</code><br>定义了一个名叫S的数组，在awk中，数组下标通常从 1 开始，而不是 0。<br><code>NF</code><br>当前记录里域个数，默认以空格分隔，如上所示的记录，NF域个数等于<br><code>$NF</code><br>表示一行的最后一个域的值，如上所示的记录，$NF也就是$6，表示第6个字段的值，也就是SYN_RECV或TIME_WAIT等。<br><code>S[$NF]</code><br>表示数组元素的值，如上所示的记录，就是S[TIME_WAIT]状态的连接数<br><code>++S[$NF]</code><br>表示把某个数加一，如上所示的记录，就是把S[TIME_WAIT]状态的连接数加一<br>结果就是显示S数组中最终的数组值<br>例：S[TIME_WAIT]=最终值 S[TESTABLISHED]=最终值<br><code>END</code><br><code>for(key in S)</code><br>遍历S[]数组<br><code>print key,”\t”,S[key]</code><br>打印数组的键和值，中间用\t制表符分割，显示好一些。</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://www.cnblogs.com/snowsolf/p/3325235.html" target="_blank" rel="external">https://www.cnblogs.com/snowsolf/p/3325235.html</a><br><a href="http://www.jb51.net/article/54961.htm" target="_blank" rel="external">http://www.jb51.net/article/54961.htm</a><br><a href="http://blog.csdn.net/joby1981/article/details/19346279" target="_blank" rel="external">http://blog.csdn.net/joby1981/article/details/19346279</a></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[利用系统安装盘修复系统误操作]]></title>
      <url>/2017/11/15/%E5%88%A9%E7%94%A8%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E7%9B%98%E4%BF%AE%E5%A4%8D%E7%B3%BB%E7%BB%9F%E8%AF%AF%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<blockquote>
<p>&emsp;&emsp;在最近配置系统启动时意外导致了系统不能正常启动，身边又没有其他可以借助的系统来修改系统盘文件，于是想到了通过系统镜像自带的系统修复工具（Troubleshooting）进行修复。</p>
</blockquote>
<p><em>修复功能不限于本文中故障，只是示例，抛砖引玉</em><br><a id="more"></a></p>
<h5 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h5><ol>
<li>工具<ul>
<li>U盘</li>
<li>镜像刻录工具</li>
<li>故障系统相应的镜像</li>
</ul>
</li>
<li>将系统镜像烧录到U盘，U盘后将作为启动盘</li>
</ol>
<h5 id="故障情景还原"><a href="#故障情景还原" class="headerlink" title="故障情景还原"></a>故障情景还原</h5><ol>
<li><p>进入系统，删除或启动<code>/etc/fstab</code>到其他位置，目的是使系统出现系统内不可恢复故障</p>
<img src="/2017/11/15/利用系统安装盘修复系统误操作/1.jpg" alt="1.jpg" title=""> 
</li>
<li><p>重启系统后系统出现故障，文件只读。如尝试 vim 打开文件，保存退出时无法保存</p>
<img src="/2017/11/15/利用系统安装盘修复系统误操作/2.jpg" alt="2.jpg" title=""> 
</li>
</ol>
<h5 id="解决故障"><a href="#解决故障" class="headerlink" title="解决故障"></a>解决故障</h5><p>为方便示例，此处采用的是虚拟机，所以可通过远程挂载镜像实现安装盘启动，与U盘启动同理</p>
<ol>
<li><p>插入U盘，设为启动盘，启动镜像。</p>
<img src="/2017/11/15/利用系统安装盘修复系统误操作/3.jpg" alt="3.jpg" title=""> 
<img src="/2017/11/15/利用系统安装盘修复系统误操作/4.jpg" alt="4.jpg" title=""> 
</li>
<li><p>选择<code>Troubleshooting</code> 选项</p>
<img src="/2017/11/15/利用系统安装盘修复系统误操作/5.jpg" alt="5.jpg" title=""> 
</li>
<li><p>选择<code>Rescue a ...</code>选项，进入到如下界面</p>
<img src="/2017/11/15/利用系统安装盘修复系统误操作/6.jpg" alt="6.jpg" title=""> 
<img src="/2017/11/15/利用系统安装盘修复系统误操作/7.jpg" alt="7.jpg" title=""> 
</li>
<li><p>选择选项”1) Continue”，后点击”Enter”,此时我们就获得了一个shell窗口</p>
</li>
<li><p>可<code>lsblk</code>查看当前分区，输入<code>chroot /mnr/sysimage</code>,切换根目录为硬盘系统根目录，此时即可对系统进行相应操作</p>
<img src="/2017/11/15/利用系统安装盘修复系统误操作/8.jpg" alt="8.jpg" title=""> 
<img src="/2017/11/15/利用系统安装盘修复系统误操作/9.jpg" alt="9.jpg" title=""> 
</li>
<li><p>在此解决本机故障，将“/etc”目录下“fstab”文件还原，后<code>exit</code>退出，即可完成修复</p>
<img src="/2017/11/15/利用系统安装盘修复系统误操作/10.jpg" alt="10.jpg" title=""></li>
</ol>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[将硬盘系统装进虚拟机]]></title>
      <url>/2017/10/29/%E5%B0%86%E7%A1%AC%E7%9B%98%E7%B3%BB%E7%BB%9F%E8%A3%85%E8%BF%9B%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      <content type="html"><![CDATA[<h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>&emsp;&emsp;本文并非是虚拟机安装系统教程，而是将已经硬盘上在跑的系统通过操作安装进虚拟机。</p>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>&emsp;&emsp;在实验工作中实现<strong>“保存现有系统盘内镜像-&gt;还原”</strong>的操作一般是利用<code>dd</code>、ghost32、Total Recovery等工具或专门的备盘设备进行系统镜像备份操作，然后在硬盘镜像损坏或操作失误以后再进行镜像还原，这个过程类似虚拟机“快照”功能。如果能<strong>将做好的硬盘中的镜像做成vmdk格式虚拟硬盘镜像，即可实现在虚拟机中运行硬盘中已架好环境的系统镜像的目的</strong>，可简化一些工作流程，提高效率。<a id="more"></a>（如作为Server的提供网络、时间同步、TFTP、DHCP等服务的主机，但不适用于需系统读取系统硬件信息的测试主机，因为虚拟机内无法Cover host主机所有硬件配置）</p>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p><a href="#1">1. ghost32 硬盘镜像导出</a><br><a href="#2">2. 镜像格式转换</a><br><a href="#3">3. 新建虚拟机</a><br><a href="#4">4. 替换虚拟硬盘镜像</a><br><a href="#5">5. 虚拟机设置</a><br><a href="#6">6. 开机测试</a></p>
<h4 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h4><pre><code>测试系统：Redhat6.5
测试环境：Win7 
测试工具：ghost32 + VMware10
</code></pre><h5 id="1-ghost32-硬盘镜像导出"><a href="#1-ghost32-硬盘镜像导出" class="headerlink" title="1. ghost32 硬盘镜像导出"></a><span id="1">1. ghost32 硬盘镜像导出</span></h5><ul>
<li>进入ghost32所在文件夹，按住<code>shift</code>鼠标右键文件夹空白处打开命令行窗口，输入<code>ghost32.exe /IAL</code>调出ghost32界面，选择<code>Local</code>-&gt;<code>Disk</code>-&gt;<code>To Image</code>然后选择硬盘进行备份操作<br><em>注：  a. 勿用ghost32备份正在运行的系统，注意预留足够的空间存放备份镜像;b. ghost32 11.5.1版本可直接将镜像备份成vmdk格式，可省去第二步，直接进行第三步  
</em><br>如图<img src="/2017/10/29/将硬盘系统装进虚拟机/command.jpg" alt="command" title="command">  
<img src="/2017/10/29/将硬盘系统装进虚拟机/menu.jpg" alt="menu" title="menu">  
<img src="/2017/10/29/将硬盘系统装进虚拟机/ghosting.jpg" alt="ghosting" title="ghosting">  
</li>
</ul>
<h5 id="2-镜像格式转换"><a href="#2-镜像格式转换" class="headerlink" title="2. 镜像格式转换"></a><span id="2">2. 镜像格式转换</span></h5><p>依旧在ghost32 进行镜像格式转换，命令:<code>ghost32.exe -clone,mode=restore,src=example.GHO,dst=example.vmdk -batch -sure</code>,“example”替换为相应文件名。如图<br><img src="/2017/10/29/将硬盘系统装进虚拟机/gho2vmware.jpg" alt="gho2vmware" title="gho2vmware"><br><img src="/2017/10/29/将硬盘系统装进虚拟机/gho2vmware-ing.jpg" alt="gho2vmware-ing" title="gho2vmware-ing">  </p>
<h5 id="3-新建虚拟机"><a href="#3-新建虚拟机" class="headerlink" title="3. 新建虚拟机"></a><span id="3">3. 新建虚拟机</span></h5><p>创建新的虚拟机-&gt;典型-&gt;稍后安装操作系统-&gt;linux（版本Red Hat Enterprise Linux 6 64 位）-&gt;位置（自由设定）-&gt;磁盘大小默认，后续会替换掉-&gt;将虚拟磁盘存储为单个硬盘，完成后虚拟机信息如图<br><img src="/2017/10/29/将硬盘系统装进虚拟机/vm-client-info.jpg" alt="vm-client-info" title="vm-client-info">  </p>
<h5 id="4-替换虚拟硬盘镜像"><a href="#4-替换虚拟硬盘镜像" class="headerlink" title="4. 替换虚拟硬盘镜像"></a><span id="4">4. 替换虚拟硬盘镜像</span></h5><p>点击上图<strong>编辑虚拟机设置</strong>，选择硬盘，点击右下角<strong>移除</strong>，点击右下角<strong>添加</strong>一个硬盘，<strong>使用现有虚拟磁盘</strong>，然后选择步骤1和2生成的vmdk镜像，如图  </p>
<img src="/2017/10/29/将硬盘系统装进虚拟机/delect_HDD.jpg" alt="delect_HDD" title="delect_HDD">  
<img src="/2017/10/29/将硬盘系统装进虚拟机/select_HDD.jpg" alt="select_HDD" title="select_HDD"> 
<img src="/2017/10/29/将硬盘系统装进虚拟机/setting_HDD.jpg" alt="setting_HDD" title="setting_HDD">  
<img src="/2017/10/29/将硬盘系统装进虚拟机/setting_HDD1.jpg" alt="setting_HDD1" title="setting_HDD1">  
<img src="/2017/10/29/将硬盘系统装进虚拟机/setting_HDD_Path.jpg" alt="setting_HDD_Path" title="setting_HDD_Path">  
<h5 id="5-虚拟机设置"><a href="#5-虚拟机设置" class="headerlink" title="5. 虚拟机设置"></a><span id="5">5. 虚拟机设置</span></h5><ol>
<li>当所做系统为网络上Server使用时，可能需要使虚拟机使用host的IP地址，可做如下配置<br>点击上图<strong>编辑虚拟机设置</strong>，选择<strong>网络适配器</strong>，选择<strong>桥接</strong>，如图  <img src="/2017/10/29/将硬盘系统装进虚拟机/bridge_network.jpg" alt="bridge_network" title="bridge_network">  </li>
<li>当所做系统作为普通虚拟机，测试搭建环境等功能使用时，可使用设置<strong>网络适配器</strong>为NAT模式（新建虚拟机默认为NAT模式） </li>
</ol>
<h5 id="6-开机测试"><a href="#6-开机测试" class="headerlink" title="6. 开机测试"></a><span id="6">6. 开机测试</span></h5><img src="/2017/10/29/将硬盘系统装进虚拟机/starting1.jpg" alt="starting" title="starting">  
<img src="/2017/10/29/将硬盘系统装进虚拟机/starting.jpg" alt="starting..." title="starting...">  
<h4 id="开机调试"><a href="#开机调试" class="headerlink" title="开机调试"></a>开机调试</h4><h5 id="Error-1"><a href="#Error-1" class="headerlink" title="Error 1"></a>Error 1</h5><p>如果按正常流程，在上述步骤时，虚拟机已经可以正常使用，但是在我实际操作时，在进入开机界面以后跳出如下错误：<br><img src="/2017/10/29/将硬盘系统装进虚拟机/poweron_error.jpg" alt="poweron_error" title="poweron_error">  </p>
<ol>
<li><p>图示为内核加载时出错，尝试手动加载内核。在开机出现内核加载倒数时按<code>e</code>，出现下图界面  </p>
<img src="/2017/10/29/将硬盘系统装进虚拟机/edit_grub.jpg" alt="edit_grub" title="edit_grub">   
</li>
<li><p>在此界面按<code>c</code>，进入grub命令行模式，输入命令如下图，关于grub下操作请转文末 <a href="#II">附录II</a> ,命令需因系统配置不同而进行相应修改  </p>
<img src="/2017/10/29/将硬盘系统装进虚拟机/grub1.jpg" alt="grub1" title="grub1">   
<img src="/2017/10/29/将硬盘系统装进虚拟机/grub2.jpg" alt="grub2" title="grub2">   
</li>
<li><p>上述输入<code>boot</code>命令后即可成功启动，如下图，接下来就是进入系统修改grub文件，要不然每次启动系统都需要输入上图三个命令，不得烦死，“懒惰即美德”嘛！</p>
<img src="/2017/10/29/将硬盘系统装进虚拟机/startIssue.jpg" alt="startIssue" title="startIssue">  
</li>
</ol>
<h5 id="Error-2"><a href="#Error-2" class="headerlink" title="Error 2"></a>Error 2</h5><ol>
<li><p>在上述 Error 1 解决之后进入系统，如上图，输入密码即可运行命令，但是当对文件进行写操作时出现下图错误,更不要说更改grub文件了。。。</p>
<img src="/2017/10/29/将硬盘系统装进虚拟机/edit_issue.jpg" alt="edit_issue" title="edit_issue">  
</li>
<li><p>这时候才注意到 Error 1 步骤3的图有些不对劲，看样子像是开机时文件系统没有正常加载，查看<code>/etc/fstab</code>如下图  </p>
<img src="/2017/10/29/将硬盘系统装进虚拟机/old_fstab.jpg" alt="old_fstab" title="old_fstab">  
</li>
<li><p>想尝试修改<code>/etc/fstab</code>文件，可是由于系统没有正常加载文件系统，无法进行文件的写操作，即就算改完了这个文件，你也只能像第一步图中那样无法保存。至此事情陷入死胡同。。。</p>
</li>
<li><p>本着“办法总比困难多”的想法，尝试将之前步骤生成的vmdk虚拟硬盘通过“虚拟机添加硬盘”的方式添加到到我正常工作的虚拟机中（相当于挂载到别的系统，然后修改此虚拟硬盘内的文件后再以此虚拟硬盘做系统盘开机），然后开机，Bingo！竟然真的能读到硬盘，接下来就是<code>lsblk</code>查看硬盘分区，<code>mount</code>硬盘，修改<code>/etc/fstab</code>，具体操作如图  </p>
<img src="/2017/10/29/将硬盘系统装进虚拟机/new_fstab.jpg" alt="new_fstab" title="new_fstab">  
<img src="/2017/10/29/将硬盘系统装进虚拟机/edit_fstab.jpg" alt="edit_fstab" title="edit_fstab">  
<p><em>（此处是将我改好的fstab文件覆盖掉硬盘原来的fstab，可直接用<code>vim</code>修改）</em></p>
</li>
<li><p>修改完后，将此虚拟机关机，重新将之前以咱们做的虚拟硬盘为主盘的系统开机，重复 Error 1 的操作开机即可发现系统已可正常开机，如下图</p>
<img src="/2017/10/29/将硬盘系统装进虚拟机/success.jpg" alt="success" title="success"> 
</li>
<li><p>接下来就是修改<code>/boot/grub/grub.conf</code>文件了,具体操作如图，第一个图为原版，注意新旧比较</p>
<img src="/2017/10/29/将硬盘系统装进虚拟机/old_grub.jpg" alt="old_grub" title="old_grub"> 
<img src="/2017/10/29/将硬盘系统装进虚拟机/new_grub.jpg" alt="new_grub" title="new_grub"> 
</li>
<li><p>此时尝试 “ifconfig” 获取ip地址，若在保证虚拟机各个服务正常运行的情况下不能获取到ip，可尝试删除”/etc/udev/rules.d/70-persidtent-net.rules”,重启系统验证</p>
<h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><h5 id="附录I"><a href="#附录I" class="headerlink" title="附录I"></a>附录I</h5><p>将 vmdk 文件转为 gho 格式命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ghost32.exe -clone,mode=create,src=example.vmdk,dst=example.gho -batch -sure</div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="附录II"><a href="#附录II" class="headerlink" title="附录II"></a><span id="II">附录II</span></h5><p>Grub 下操作总结：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">grub&gt; root (hd0,) # 输入 root (hd0,) 这时按 TAB 键会打印出系统上所有的分区 ( 注意在急救模式下不支持 TAB , 很伤~ )</div><div class="line">Possible partitions are:</div><div class="line">Partition num: 0, Filesystem type is ext2fs, partition type 0x83</div><div class="line">Partition num: 1, Filesystem type unknown, partition type 0x82</div><div class="line">Partition num: 2, Filesystem type is ext2fs, partition type 0x83</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;0, 1, 2 代表分区编号，上面显示有文件系统，分区类型，像 83 就是 Linux 普通分区，82 是虚拟分区 SWAP ( 硬盘分区时的知识 )<br>&emsp;&emsp;这里不分 IDE / SATA 什么的，都用 hd 代表，hd0 代表第一块硬盘，hd0,0 代表第一块硬盘的第一个分区，系统中是用 sda1 代表第一块硬盘的第一个分区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grub&gt; root (hd0,0)/</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;输入 root (hd0,0)/ 这里按 TAB 键搜索内核在不在此分区上 ( boot 分区 )，如果有会输出下面信息 ( 试 83 的分区，82 是交换分区就没必要试了 )<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Possible files are: lost+found grub efi .VMlinuz-2.6.32-504.e16.x86_64.hmac System.map-2.6.32-504.e16.x86_64 config-2.6.32-504.x86_64 symvers-2.6.32-504.x86_64.gz VMlinuz-2.6.32-504.e16.x86_64 initramfs-2.6.32-504.e16.x86_64.img</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;如果可以看到 vmlinuz- 跟 initramfs- 字样，说明这就是我们想要的东西<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grub&gt; root (hd0,2)/</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;下面是搜不到的显示, 仔细看看 ( 发现这是根分区哎~~ hd0,2 是根分区，我们用的是 SATA , 所以根分区是 /dev/sda3 很有用 ！)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Possible files are: lost+found boot dev proc sys var tmp etc root selinux lib64 usr bin home lib media mnt opt sbin srv .autorelabel</div></pre></td></tr></table></figure></p>
<p><strong>绑定启动分区</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">grub&gt; root (hd0,0) </div><div class="line">Filesystem type is ext2fs, partition type 0x83</div><div class="line"></div><div class="line">grub&gt; kernel /VMlinuz-2.6.32-504.e16.x86_64 ro root=/dev/sda3 # 指定启动内核，ro 只读模式，root= 指定根分区, 一定要指对 ( 可能如果 boot 没有单独分区不指定也是可以的 )</div><div class="line"></div><div class="line">grub&gt; initrd /initramfs-2.6.32-504.e16.x86_64.img # 这是内核映像吧 ( kernel 、initrd 都是上面搜出来的，输入一点点按 TAB 可以补全 )</div><div class="line"></div><div class="line">grub&gt; boot # 启动系统，手动编写 grub.conf 或恢复备份</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Vmware </category>
            
            <category> 系统安装 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> VMware </tag>
            
            <tag> 系统安装 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[搭梯子：Shadowsocks 一键安装脚本（四合一）]]></title>
      <url>/2017/10/23/%E6%90%AD%E6%A2%AF%E5%AD%90%EF%BC%9AShadowsocks-%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC%EF%BC%88%E5%9B%9B%E5%90%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p><strong><em>转自文章 <a href="https://teddysun.com/486.html" target="_blank" rel="external">Shadowsocks 一键安装脚本（四合一）</a></em></strong></p>
<h4 id="本脚本适用环境"><a href="#本脚本适用环境" class="headerlink" title="本脚本适用环境"></a>本脚本适用环境</h4><p>系统支持：CentOS 6+，Debian 7+，Ubuntu 12+<br>内存要求：≥128M</p>
<font color="#DC143C">日期　　：2017 年 10 月 22 日</font>


<h4 id="关于本脚本"><a href="#关于本脚本" class="headerlink" title="关于本脚本"></a>关于本脚本</h4><ol>
<li>一键安装 Shadowsocks-Python， ShadowsocksR， Shadowsocks-Go， Shadowsocks-libev 版（四选一）服务端；</li>
<li>各版本的启动脚本及配置文件名不再重合；</li>
<li>每次运行可安装一种版本；</li>
<li>支持以多次运行来安装多个版本，且各个版本可以共存（注意端口号需设成不同）；</li>
<li>若已安装多个版本，则卸载时也需多次运行（每次卸载一种）；</li>
<li>Shadowsocks-Python 和 ShadowsocksR 安装后不可同时启动（因为本质上都属 Python 版）。</li>
</ol>
<p><font color="#DC143C"><strong>友情提示</strong>：</font>如果你有问题，请先阅读这篇《<a href="https://teddysun.com/399.html" target="_blank" rel="external">Shadowsocks Troubleshooting</a>》之后再询问。<br><a id="more"></a></p>
<h4 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h4><p>服务器端口：自己设定（如不设定，默认为 8989）<br>密码：自己设定（如不设定，默认为 teddysun.com）<br>加密方式：自己设定（如不设定，Python 和 libev 版默认为 aes-256-gcm，R 和 Go 版默认为 aes-256-cfb）<br>协议（protocol）：自己设定（如不设定，默认为 origin）（仅限 ShadowsocksR 版）<br>混淆（obfs）：自己设定（如不设定，默认为 plain）（仅限 ShadowsocksR 版）<br><strong>备注</strong>：脚本默认创建单用户配置文件，如需配置多用户，请手动修改相应的配置文件后重启即可。</p>
<h4 id="客户端下载"><a href="#客户端下载" class="headerlink" title="客户端下载"></a>客户端下载</h4><p>常规版 Windows 客户端<br><a href="https://github.com/shadowsocks/shadowsocks-windows/releases" target="_blank" rel="external">https://github.com/shadowsocks/shadowsocks-windows/releases</a></p>
<p>ShadowsocksR 版 Windows 客户端<br><a href="https://github.com/shadowsocksr/shadowsocksr-csharp/releases" target="_blank" rel="external">https://github.com/shadowsocksr/shadowsocksr-csharp/releases</a></p>
<p>Android/MAC/Windows 客户端<br>百度云链接：<a href="https://pan.baidu.com/s/1pLkeXFt" target="_blank" rel="external">https://pan.baidu.com/s/1pLkeXFt</a> 密码: uv9i</p>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><h5 id="使用root用户登录，运行以下命令："><a href="#使用root用户登录，运行以下命令：" class="headerlink" title="使用root用户登录，运行以下命令："></a>使用root用户登录，运行以下命令：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh</div><div class="line">chmod +x shadowsocks-all.sh</div><div class="line">./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log</div></pre></td></tr></table></figure>
<h5 id="安装完成后，脚本提示如下"><a href="#安装完成后，脚本提示如下" class="headerlink" title="安装完成后，脚本提示如下"></a>安装完成后，脚本提示如下</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Congratulations, your_shadowsocks_version install completed!</div><div class="line">Your Server IP        :your_server_ip</div><div class="line">Your Server Port      :your_server_port</div><div class="line">Your Password         :your_password</div><div class="line">Your Encryption Method:your_encryption_method</div><div class="line"></div><div class="line">Welcome to visit:https://teddysun.com/486.html</div><div class="line">Enjoy it!  </div></pre></td></tr></table></figure>
<h5 id="卸载方法"><a href="#卸载方法" class="headerlink" title="卸载方法"></a>卸载方法</h5><p>若已安装多个版本，则卸载时也需多次运行（每次卸载一种）</p>
<p>使用root用户登录，运行以下命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./shadowsocks-all.sh uninstall</div></pre></td></tr></table></figure></p>
<h5 id="启动脚本"><a href="#启动脚本" class="headerlink" title="启动脚本"></a>启动脚本</h5><p>启动脚本后面的参数含义，从左至右依次为：启动，停止，重启，查看状态。</p>
<p>Shadowsocks-Python 版：<br>/etc/init.d/shadowsocks-python start | stop | restart | status</p>
<p>ShadowsocksR 版：<br>/etc/init.d/shadowsocks-r start | stop | restart | status</p>
<p>Shadowsocks-Go 版：<br>/etc/init.d/shadowsocks-go start | stop | restart | status</p>
<p>Shadowsocks-libev 版：<br>/etc/init.d/shadowsocks-libev start | stop | restart | status</p>
<h5 id="各版本默认配置文件"><a href="#各版本默认配置文件" class="headerlink" title="各版本默认配置文件"></a>各版本默认配置文件</h5><p>Shadowsocks-Python 版：<br>/etc/shadowsocks-python/config.json</p>
<p>ShadowsocksR 版：<br>/etc/shadowsocks-r/config.json</p>
<p>Shadowsocks-Go 版：<br>/etc/shadowsocks-go/config.json</p>
<p>Shadowsocks-libev 版：<br>/etc/shadowsocks-libev/config.json</p>
<h4 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h4><h5 id="2017-年-10-月-22-日："><a href="#2017-年-10-月-22-日：" class="headerlink" title="2017 年 10 月 22 日："></a>2017 年 10 月 22 日：</h5><p>1、升级：libsodium 到 1.0.15。</p>
<h5 id="2017-年-10-月-14-日："><a href="#2017-年-10-月-14-日：" class="headerlink" title="2017 年 10 月 14 日："></a>2017 年 10 月 14 日：</h5><p>1、新增：在安装 Shadowsocks-libev 版时可选安装 simple-obfs 服务端。<br>※ 脚本通过判断 autoconf 版本是否大于或等于 2.67 来一键安装 simple-obfs 服务端。并且，支持在安装过程中选择 obfs 为 http 或 tls。<br>※ 使用方法参考：<a href="https://teddysun.com/511.html" target="_blank" rel="external">https://teddysun.com/511.html</a></p>
<h5 id="2017-年-09-月-16-日："><a href="#2017-年-09-月-16-日：" class="headerlink" title="2017 年 09 月 16 日："></a>2017 年 09 月 16 日：</h5><p>1、修正：Shadowsocks-libev 版 v3.1.0 使用 libc-ares 替换 libudns 依赖包，解决了依赖问题；<br>2、升级：mbedtls 到版本 2.6.0。</p>
<h5 id="2017-年-07-月-27-日："><a href="#2017-年-07-月-27-日：" class="headerlink" title="2017 年 07 月 27 日："></a>2017 年 07 月 27 日：</h5><p>1、新增：ShadowsocksR 版可选协议（protocol）auth_chain_b 。使用该协议需更新到最新（4.7.0） ShadowsocksR 版客户端；<br>2、修改：更新 ShadowsocksR 源码下载地址。</p>
<h5 id="2017-年-07-月-23-日："><a href="#2017-年-07-月-23-日：" class="headerlink" title="2017 年 07 月 23 日："></a>2017 年 07 月 23 日：</h5><p>1、修正：卸载时可自行选择某个版本卸载，若该版本不存在则报错退出。</p>
<h5 id="2017-年-07-月-22-日："><a href="#2017-年-07-月-22-日：" class="headerlink" title="2017 年 07 月 22 日："></a>2017 年 07 月 22 日：</h5><p>1、修正：默认加密方式从 aes-256-cfb 改为 aes-256-gcm（Python 和 libev 版）；<br>2、新增：安装时可选 16 种加密方式的其中之一（Python 和 libev 版）。如下所示：</p>
<p>aes-256-gcm<br>aes-192-gcm<br>aes-128-gcm<br>aes-256-ctr<br>aes-192-ctr<br>aes-128-ctr<br>aes-256-cfb<br>aes-192-cfb<br>aes-128-cfb<br>camellia-128-cfb<br>camellia-192-cfb<br>camellia-256-cfb<br>chacha20-ietf-poly1305<br>chacha20-ietf<br>chacha20<br>rc4-md5<br>3、新增：安装时可选 9 种加密方式的其中之一（Go 版）。如下所示：</p>
<p>aes-256-cfb<br>aes-192-cfb<br>aes-128-cfb<br>aes-256-ctr<br>aes-192-ctr<br>aes-128-ctr<br>chacha20-ietf<br>chacha20<br>rc4-md5<br>4、新增：安装时可选 13 种加密方式的其中之一（none 是不加密，ShadowsocksR 版）。如下所示：</p>
<p>none<br>aes-256-cfb<br>aes-192-cfb<br>aes-128-cfb<br>aes-256-cfb8<br>aes-192-cfb8<br>aes-128-cfb8<br>aes-256-ctr<br>aes-192-ctr<br>aes-128-ctr<br>chacha20-ietf<br>chacha20<br>rc4-md5<br>rc4-md5-6<br>5、新增：安装时可选 7 种协议（protocol）的其中之一（仅限 ShadowsocksR 版）。如下所示：</p>
<p>origin<br>verify_deflate<br>auth_sha1_v4<br>auth_sha1_v4_compatible<br>auth_aes128_md5<br>auth_aes128_sha1<br>auth_chain_a<br>auth_chain_b<br>6、新增：安装时可选 9 种混淆（obfs）的其中之一（仅限 ShadowsocksR 版）。如下所示：</p>
<p>plain<br>http_simple<br>http_simple_compatible<br>http_post<br>http_post_compatible<br>tls1.2_ticket_auth<br>tls1.2_ticket_auth_compatible<br>tls1.2_ticket_fastauth<br>tls1.2_ticket_fastauth_compatible</p>
<h5 id="2017-年-02-月-24-日："><a href="#2017-年-02-月-24-日：" class="headerlink" title="2017 年 02 月 24 日："></a>2017 年 02 月 24 日：</h5><p>1、恢复： 通过 Github API 自动获取 Shadowsocks-libev 的最新 release 版本的功能（v3.0.3）。</p>
<h5 id="2017-年-02-月-13-日："><a href="#2017-年-02-月-13-日：" class="headerlink" title="2017 年 02 月 13 日："></a>2017 年 02 月 13 日：</h5><p>1、升级： Shadowsocks-libev 版到版本 3.0.2；<br>2、升级： Shadowsocks-go 版到版本 1.2.1（基于 Github 最新代码，用 go 1.8 编译完成的 x86 和 x86_64 二进制文件）；<br>3、修复：在 Debian 7 下默认没有 libudns-dev 依赖包的问题。</p>
<h5 id="2017-年-02-月-12-日："><a href="#2017-年-02-月-12-日：" class="headerlink" title="2017 年 02 月 12 日："></a>2017 年 02 月 12 日：</h5><p>1、升级： Shadowsocks-libev 版到版本 3.0.1。</p>
<h5 id="2017-年-01-月-27-日："><a href="#2017-年-01-月-27-日：" class="headerlink" title="2017 年 01 月 27 日："></a>2017 年 01 月 27 日：</h5><p>1、升级： Shadowsocks-go 版到版本 1.2.1 （仅适用于 x86_64 系统）</p>
<h5 id="更多单版本-Shadowsocks-服务端一键安装脚本"><a href="#更多单版本-Shadowsocks-服务端一键安装脚本" class="headerlink" title="更多单版本 Shadowsocks 服务端一键安装脚本"></a>更多单版本 Shadowsocks 服务端一键安装脚本</h5><p>Shadowsocks Python 版一键安装脚本（CentOS，Debian，Ubuntu）<br>ShadowsocksR 版一键安装脚本（CentOS，Debian，Ubuntu）<br>CentOS 下 Shadowsocks-libev 一键安装脚本<br>Debian 下 Shadowsocks-libev 一键安装脚本<br>Shadowsocks-go 一键安装脚本（CentOS，Debian，Ubuntu）</p>
<p><strong>注意：以上单版本不可与该四合一版本混用。</strong></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redhat/Ununtu16.04 添加服务]]></title>
      <url>/2017/10/22/Redhat-Ununtu16-04-%E6%B7%BB%E5%8A%A0%E6%9C%8D%E5%8A%A1/</url>
      <content type="html"><![CDATA[<blockquote>
<p>&emsp;&emsp;上周在架设<a href="https://gitea.io/zh-CN/" target="_blank" rel="external">Gitea</a>Server做个人代码管理器时，运行网页设置界面时需运行<code>路径/gitea web</code>命令，Ctrl+C 退出运行命令时网页版就会停止服务，本着<strong>懒即美德</strong>的原则，想就此做优化，预期目标是：在我想运行网页版时不需要打上一长串“难记”的路径，想停止命令时又不用 <code>kill</code>来退出它。<br>&emsp;&emsp;首先想到的是写一个脚本，然后运行脚本就可以运行/停止软件，想加入开机启动，只需要再更改 <code>.bash_profile</code> 即可。这些工作做完，重启机器，软件与预期一样，开机时候已经后台启动。Perfect！哎，等等，那我想要关掉它捏？？？好吧，最后还是决定，把它设置为开机自启动服务吧，这样就可以通过<code>service xxx start|stop|restart|status</code>控制它了！<br><a id="more"></a></p>
<h4 id="Redhat6-5-下服务配置"><a href="#Redhat6-5-下服务配置" class="headerlink" title="Redhat6.5 下服务配置"></a>Redhat6.5 下服务配置</h4><h5 id="新建-etc-gitea-将gitea各文件放入。目录可自行定义，非必须此位置"><a href="#新建-etc-gitea-将gitea各文件放入。目录可自行定义，非必须此位置" class="headerlink" title="新建/etc/gitea,将gitea各文件放入。目录可自行定义，非必须此位置"></a>新建/etc/gitea,将gitea各文件放入。目录可自行定义，非必须此位置</h5><h5 id="新建-startGitea-sh用来启动gitea，内容如下"><a href="#新建-startGitea-sh用来启动gitea，内容如下" class="headerlink" title="新建 startGitea.sh用来启动gitea，内容如下"></a>新建 startGitea.sh用来启动gitea，内容如下</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line">cd /etc/gitea</div><div class="line">nohup ./gitea web &gt; /dev/null 2&gt;&amp;1 &amp;</div></pre></td></tr></table></figure>
<h5 id="设置脚本gitd-sh-start-stop-restart-status"><a href="#设置脚本gitd-sh-start-stop-restart-status" class="headerlink" title="设置脚本gitd.sh  start|stop|restart|status"></a>设置脚本gitd.sh  start|stop|restart|status</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"></div><div class="line"><span class="meta">#</span>description: gitd.sh</div><div class="line"><span class="meta">#</span>chkconfig: 2345 20 81</div><div class="line"></div><div class="line">SERVICEEXEC=gitea</div><div class="line">EXEC_PATH=/etc/gitea/</div><div class="line">EXEC=startGitea.sh</div><div class="line">DAEMON=$EXEC_PATH$EXEC</div><div class="line">PID_FILE=/var/run/startGitea.sh.pid</div><div class="line"></div><div class="line">. /etc/rc.d/init.d/functions</div><div class="line"></div><div class="line">if [ ! -x $DAEMON ] ; then</div><div class="line">echo "ERROR: $DAEMON not found"</div><div class="line">exit 1</div><div class="line">fi</div><div class="line"></div><div class="line">stop()</div><div class="line">&#123;</div><div class="line">echo "Stoping $EXEC ..."</div><div class="line"><span class="meta">#</span>ps aux | grep "$DAEMON" | kill -9 `awk '&#123;print $2&#125;'` &gt;/dev/null 2&gt;&amp;1</div><div class="line">ps aux | grep "$SERVICEEXEC" | kill -9 `awk '&#123;print $2&#125;'` &gt;/dev/null 2&gt;&amp;1</div><div class="line">rm -f $PID_FILE</div><div class="line">usleep 100</div><div class="line">echo "Shutting down $EXEC: [  OK  ]"</div><div class="line">&#125;</div><div class="line"></div><div class="line">start()</div><div class="line">&#123;</div><div class="line">echo "Starting $EXEC ..."</div><div class="line">if [ `ps aux | grep "$SERVICEEXEC" | awk '&#123;print $2&#125;'|wc -l` -le 1 ];then</div><div class="line"><span class="meta">$</span>DAEMON &gt; /dev/null &amp;</div><div class="line">pidof $EXEC &gt; $PID_FILE</div><div class="line">usleep 100</div><div class="line">echo "Starting $EXEC: [  OK  ]"</div><div class="line">else</div><div class="line">echo "gitea is running now ! "</div><div class="line">fi</div><div class="line">&#125;</div><div class="line"></div><div class="line">restart()</div><div class="line">&#123;</div><div class="line">stop</div><div class="line">start</div><div class="line">&#125;</div><div class="line"></div><div class="line">status()</div><div class="line">&#123;</div><div class="line">if [ `ps aux | grep "$SERVICEEXEC" | awk '&#123;print $2&#125;'|wc -l` -le 1 ];then</div><div class="line">echo "gitea is not running ! "</div><div class="line">else</div><div class="line">echo "gitea is running now ! "</div><div class="line">fi</div><div class="line">&#125;</div><div class="line"></div><div class="line">case "$1" in</div><div class="line">start)</div><div class="line">start</div><div class="line">;;</div><div class="line">stop)</div><div class="line">stop</div><div class="line">;;</div><div class="line">restart)</div><div class="line">restart</div><div class="line">;;</div><div class="line">status)</div><div class="line">status -p $PID_FILE $DAEMON</div><div class="line">;;</div><div class="line">*)</div><div class="line">echo "Usage: service $EXEC &#123;start|stop|restart|status&#125;"</div><div class="line">exit 1</div><div class="line">esac</div><div class="line"></div><div class="line">exit $?</div></pre></td></tr></table></figure>
<h5 id="将脚本新建软链接到-etc-init-d"><a href="#将脚本新建软链接到-etc-init-d" class="headerlink" title="将脚本新建软链接到 /etc/init.d/"></a>将脚本新建软链接到 <code>/etc/init.d/</code></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ln -s /etc/gitea/gitd.sh /etc/init.d/gitd</div></pre></td></tr></table></figure>
<h5 id="设置开机自启动"><a href="#设置开机自启动" class="headerlink" title="设置开机自启动"></a>设置开机自启动</h5><ol>
<li>在chkconfig工具服务列表中增加此服务<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chkconfig --add gitd </div></pre></td></tr></table></figure></li>
<li>修改服务的默认启动等级<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chkconfig gitd on</div></pre></td></tr></table></figure>  
</li>
</ol>
</blockquote>
<h5 id="查看-删除服务"><a href="#查看-删除服务" class="headerlink" title="查看/删除服务"></a>查看/删除服务</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chkconfig --list|grep gitd</div><div class="line">chkconfig --del gitd</div></pre></td></tr></table></figure>
<hr>
<h4 id="Ubuntu16-04-下服务配置"><a href="#Ubuntu16-04-下服务配置" class="headerlink" title="Ubuntu16.04 下服务配置"></a>Ubuntu16.04 下服务配置</h4><blockquote>
<p>类比上文 “redhat6.5将脚本注册为服务”</p>
</blockquote>
<h5 id="同Redhat-第1步"><a href="#同Redhat-第1步" class="headerlink" title="同Redhat 第1步"></a>同Redhat 第1步</h5><h5 id="设置服务脚本（注意BEGIN-INIT-INFO至END-INIT-INFO部分）"><a href="#设置服务脚本（注意BEGIN-INIT-INFO至END-INIT-INFO部分）" class="headerlink" title="设置服务脚本（注意BEGIN INIT INFO至END INIT INFO部分）"></a>设置服务脚本（注意<code>BEGIN INIT INFO</code>至<code>END INIT INFO</code>部分）</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"></div><div class="line"><span class="meta">#</span>## BEGIN INIT INFO</div><div class="line"><span class="meta">#</span> Provides:          Gitd</div><div class="line"><span class="meta">#</span> Required-Start:    $network $local_fs $remote_fs</div><div class="line"><span class="meta">#</span> Required-Stop:     $network $local_fs $remote_fs</div><div class="line"><span class="meta">#</span> Default-Start:     2 3 4 5</div><div class="line"><span class="meta">#</span> Default-Stop:      0 1 6</div><div class="line"><span class="meta">#</span> Short-Description: The git server --- Gitea</div><div class="line"><span class="meta">#</span> Description:       Start or stop the ShadowsocksR server</div><div class="line"><span class="meta">#</span>## END INIT INFO</div><div class="line"></div><div class="line">SERVICEEXEC=gitea</div><div class="line">EXEC_PATH=/etc/gitea/</div><div class="line">EXEC=startGitea.sh</div><div class="line">DAEMON=$EXEC_PATH$EXEC</div><div class="line">PID_FILE=/var/run/startGitea.sh.pid</div><div class="line"></div><div class="line"><span class="meta">#</span>. /etc/rc.d/init.d/functions</div><div class="line"></div><div class="line">if [ ! -x $DAEMON ] ; then</div><div class="line">echo "ERROR: $DAEMON not found"</div><div class="line">exit 1</div><div class="line">fi</div><div class="line"></div><div class="line">stop()</div><div class="line">&#123;</div><div class="line">echo "Stoping $EXEC ..."</div><div class="line"><span class="meta">#</span>ps aux | grep "$DAEMON" | kill -9 `awk '&#123;print $2&#125;'` &gt;/dev/null 2&gt;&amp;1</div><div class="line">ps aux | grep "$SERVICEEXEC" | kill -9 `awk '&#123;print $2&#125;'` &gt;/dev/null 2&gt;&amp;1</div><div class="line">rm -f $PID_FILE</div><div class="line">sleep 0.1</div><div class="line">echo "Shutting down $EXEC: [  OK  ]"</div><div class="line">&#125;</div><div class="line"></div><div class="line">start()</div><div class="line">&#123;</div><div class="line">echo "Starting $EXEC ..."</div><div class="line">if [ `ps aux | grep "$SERVICEEXEC" |grep -v grep | awk '&#123;print $2&#125;'|wc -l` -le 2 ];then</div><div class="line"><span class="meta">$</span>DAEMON &gt; /dev/null &amp;</div><div class="line">pidof $EXEC &gt; $PID_FILE</div><div class="line">sleep 0.1</div><div class="line">echo "Starting $EXEC: [  OK  ]"</div><div class="line">else</div><div class="line">echo "gitea is running now ! "</div><div class="line">fi</div><div class="line">&#125;</div><div class="line"></div><div class="line">restart()</div><div class="line">&#123;</div><div class="line">stop</div><div class="line">start</div><div class="line">&#125;</div><div class="line"></div><div class="line">status()</div><div class="line">&#123;</div><div class="line">if [ `ps aux | grep "$SERVICEEXEC" | awk '&#123;print $2&#125;'|wc -l` -le 1 ];then</div><div class="line">echo "gitea is not running ! "</div><div class="line">else</div><div class="line">echo "gitea is running now ! "</div><div class="line">fi</div><div class="line">&#125;</div><div class="line"></div><div class="line">case "$1" in</div><div class="line">start)</div><div class="line">start</div><div class="line">;;</div><div class="line">stop)</div><div class="line">stop</div><div class="line">;;</div><div class="line">restart)</div><div class="line">restart</div><div class="line">;;</div><div class="line">status)</div><div class="line">status -p $PID_FILE $DAEMON</div><div class="line">;;</div><div class="line">*)</div><div class="line">echo "Usage: service $EXEC &#123;start|stop|restart|status&#125;"</div><div class="line">exit 1</div><div class="line">esac</div><div class="line"></div><div class="line">exit $?</div></pre></td></tr></table></figure>
<h5 id="添加服务"><a href="#添加服务" class="headerlink" title="添加服务"></a>添加服务</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ln -s xxxxx /etc/init.d/gitd</div><div class="line">update-rc.d -f gitd defaults</div></pre></td></tr></table></figure>
<p>删除：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">update-rc.d -f gitd remove</div></pre></td></tr></table></figure></p>
<h5 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">systemctl daemon-reload    （更新服务后需要执行这一步）</div><div class="line">service gitd restart</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SVN服务器进阶-VisualSVN-Server和TortoiseSVN]]></title>
      <url>/2017/10/16/SVN%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E9%98%B6-VisualSVN-Server%E5%92%8CTortoiseSVN%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h5 id="VisualSVN-Server介绍"><a href="#VisualSVN-Server介绍" class="headerlink" title="VisualSVN Server介绍"></a>VisualSVN Server介绍</h5><p>VisualSVN Server是免费的，而VisualSVN是收费的。VisualSVN是SVN的客户端，和Visual Studio集成在一起， VisualSvn Server是SVN的服务器端，包括Subversion、Apache和用户及权限管理</p>
<h5 id="VisualSVN相较Subversion优势"><a href="#VisualSVN相较Subversion优势" class="headerlink" title="VisualSVN相较Subversion优势"></a>VisualSVN相较Subversion优势</h5><p>如果直接使用Subversion，那么在Windows 系统上，要想让它随系统启动，就要封装SVN Server为windws service，还要通过修改配置文件来控制用户权限，另外如果要想以Web方式–“http协议访问”，一般还要安装配置Apache，对于新手十分不友好，而VisualSVN Serve集成了Subversion和Apache，省去了以上所有的麻烦。安装的时候SVN Server已经封装为windws service，Apache服务器的配置也只是在图像界面上，指定认证方式、访问端口等简单操作；另外，用户权限的管理也是通过图像界面来配置。<br><a id="more"></a></p>
<h5 id="VisualSVN安装下载"><a href="#VisualSVN安装下载" class="headerlink" title="VisualSVN安装下载"></a>VisualSVN安装下载</h5><h6 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h6><p>下载地址：<a href="https://www.visualsvn.com/downloads/" target="_blank" rel="external">https://www.visualsvn.com/downloads/</a></p>
<img src="/2017/10/16/SVN服务器进阶-VisualSVN-Server和TortoiseSVN配置/download.jpg" alt="downloadVisualSVN" title="downloadVisualSVN">
<p>选择VisualSVN Server，选择32/64位下载</p>
<h6 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h6><p>软件安装一步步选择默认配置即可，当安装流程到如下图时选择<code>Standard Edition</code>即可<br><br>安装到下图时可对软件安装目录和资源库所在的位置及端口号进行设置，如果用默认的HTTPS，端口有443和8443，如果不用HTTPS，端口就是80和8080，如下图。此处可先保持默认设置，可在软件启动后进行设置<br><img src="/2017/10/16/SVN服务器进阶-VisualSVN-Server和TortoiseSVN配置/https.jpg" alt="https" title="https"><br><img src="/2017/10/16/SVN服务器进阶-VisualSVN-Server和TortoiseSVN配置/http.jpg" alt="http" title="http">  </p>
<h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>整体界面，左边从上到下是SVN本地服务器、资源库、用户、用户组等。<br>右边从上到下是服务状态、日志信息及配置、认证信息及配置、资源库信息及配置。最下面有更新，版本号之类的<br><img src="/2017/10/16/SVN服务器进阶-VisualSVN-Server和TortoiseSVN配置/menu.jpg" alt="menu" title="menu"><br>打开电脑服务，可看到已经生成了相应的服务<br><img src="/2017/10/16/SVN服务器进阶-VisualSVN-Server和TortoiseSVN配置/serve.jpg" alt="serve" title="serve"><br>如下图，右键SVN本地服务器，“Properties”可对服务器进行资源库，http类型及端口等设置，在此不过多介绍<br><img src="/2017/10/16/SVN服务器进阶-VisualSVN-Server和TortoiseSVN配置/properties.jpg" alt="properties" title="properties">  </p>
<h6 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h6><ol>
<li>如图右键<code>Repositories</code>,选择<code>Creat New Repository</code>或者<code>新建</code>-&gt;<code>Repository</code>  <img src="/2017/10/16/SVN服务器进阶-VisualSVN-Server和TortoiseSVN配置/new_properties1.jpg" alt="new_properties1" title="new_properties1">  </li>
<li>此处科普一下两种repository不同。<a href="#1">①</a>  <img src="/2017/10/16/SVN服务器进阶-VisualSVN-Server和TortoiseSVN配置/multisite-replication.jpg" alt="multisite-replication" title="multisite-replication">  </li>
<li>仓库结构，这里选第一个空的，下面那个在建成后会自动存在三个文件夹:trunk,branches,tags  <img src="/2017/10/16/SVN服务器进阶-VisualSVN-Server和TortoiseSVN配置/new_properties2.jpg" alt="new_properties2" title="new_properties2">  </li>
<li>仓库的访问权限设置，Nobody has access是所人有都不可访问，第二个是所有的SVN用户都可以读写，最后是自定义权限，按默认的来吧！  <img src="/2017/10/16/SVN服务器进阶-VisualSVN-Server和TortoiseSVN配置/new_properties3.jpg" alt="new_properties3" title="new_properties3">  </li>
<li>最后显示配置的仓库类型为FSFS，仓库名是”test1”，URL是 “<a href="https://pedro-PC/svn/test1" target="_blank" rel="external">https://pedro-PC/svn/test1</a>“ ，因为我们用的是https协议，<em>“pedro-PC”</em>可以用IP代替，<em>“pedro-PC/svn”</em>是根目录,<em>“svn/test1”</em>是虚拟的SVN目录，并不是我们设置的实际目录，权限默认为所有人可读写。  <img src="/2017/10/16/SVN服务器进阶-VisualSVN-Server和TortoiseSVN配置/new_properties4.jpg" alt="new_properties4" title="new_properties4">  </li>
<li>访问”<a href="https://pedro-PC/svn/test1" target="_blank" rel="external">https://pedro-PC/svn/test1</a>“ ，如图，则表示安装成功。  <img src="/2017/10/16/SVN服务器进阶-VisualSVN-Server和TortoiseSVN配置/new_properties5.jpg" alt="new_properties5" title="new_properties5">  </li>
<li>右键新建好的仓库，弹出的菜单中，可通过<code>Properties</code>设置可访问仓库的用户，用户的创建则可通过<code>Users</code>,<code>Groups</code>菜单操作。  <img src="/2017/10/16/SVN服务器进阶-VisualSVN-Server和TortoiseSVN配置/new_properties6.jpg" alt="new_properties6" title="new_properties6">  </li>
<li>接下来就靠读者自行探索了。可参考“Subversion+TortoiseSVN”组合。</li>
</ol>
<h5 id="TortiseSVN-检出操作提醒"><a href="#TortiseSVN-检出操作提醒" class="headerlink" title="TortiseSVN 检出操作提醒"></a>TortiseSVN 检出操作提醒</h5><p>在我最初架好Server端后，从svn做下载动作，checkout的时候老是弹出如下问题<br><img src="/2017/10/16/SVN服务器进阶-VisualSVN-Server和TortoiseSVN配置/new_properties7.jpg" alt="new_properties7" title="new_properties7"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">The XML response contains invalid XML</div><div class="line">Malformed XML: no element found</div></pre></td></tr></table></figure></p>
<p>先是检查了N遍Server，没有问题，又按百度的方法clear了N次都不行。<br>原因：在服务器访问仓库时，只需输入<code>http://IP/</code>即可，但是在使用TortoiseSVN同步时，地址应写完整<br>正确的地址：<br><a href="https://IP/svn/xxx" target="_blank" rel="external">https://IP/svn/xxx</a></p>
<h5 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h5><h6 id="FSFS与VDFS"><a href="#FSFS与VDFS" class="headerlink" title="FSFS与VDFS"></a><span id="1">FSFS与VDFS</span></h6><p>VDFS是基于FSFS的，公司的官网有介绍：<a href="https://www.visualsvn.com/server/features/multisite-replication/" target="_blank" rel="external">VisualSVN Server</a></p>
<blockquote>
<p>It’s worth to notice that VDFS data store is built on top of the standard    FSFS backend. The existing FSFS-based repositories can be instantly    converted into a VDFS repository. Moreover, there is no data lock-in and you    can instantly convert a VDFS repository back into a regular FSFS-based    repository.   </p>
</blockquote>
<p>简单来说这个是VisualSVN基于FSFS文件系统格式扩展的，根据wikipedia的说法：<a href="https://en.wikipedia.org/wiki/VisualSVN_Server" target="_blank" rel="external">VisualSVN Server</a></p>
<blockquote>
<p>VisualSVN Distributed File System (VDFS). Multisite Repository Replication is based on VDFS technology. VDFS enables automatic, transparent, bidirectional replication of Subversion repositories between multiple locations (each slave repository is writeable). VDFS follows the classic master / slave replication architecture and uses Microsoft RPC as its transport layer.</p>
</blockquote>
<p>也就是说，分布式版本管理DVCS兴起之后，大家发现多个仓库的好处了，开始给SVN增加这个功能。至于FSFS本身是SVN在2004年开始替换Berkeley DB的，是基于文件系统概念设计的，而不是基于数据库的概念，根据 <a href="http://svnbook.red-bean.com/en/1.1/ch05.html" target="_blank" rel="external">http://svnbook.red-bean.com/en/1.1/ch05.html</a>的说法，采用目录树的结构去做transaction，可以在目录外创建完一次提交，然后把完成的提交一次性移动进版本历史。另外，根据他们的数据结构，对Berkeley DB的append操作是O(N^2)的，而FSFS是O(N)的。当然更完整的介绍可以看：<a href="http://svn.apache.org/repos/asf/subversion/tags/1.8.4/notes/fsfs" target="_blank" rel="external">http://svn.apache.org/repos/asf/subversion/tags/1.8.4/notes/fsfs</a>如果你不是太在乎私有格式，也需要多仓库同步，可以用VDFS，官方文档说了VDFS默认的service是没有启动的，所以对你日常应该没有影响。如果不喜欢私有格式，就用FSFS就好。</p>
]]></content>
      
        <categories>
            
            <category> SVN </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SVN </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SVN服务器搭建--Subversio和TortoiseSVN配置]]></title>
      <url>/2017/10/15/SVN%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA-Subversion%E5%92%8CTortoiseSVN%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;<strong>本文主要介绍Windows下SVN组合：Subversion和TortoiseSVN安装配置</strong></p>
<h5 id="软件下载："><a href="#软件下载：" class="headerlink" title="软件下载："></a>软件下载：</h5><ul>
<li>Subversion ：<a href="https://www.visualsvn.com/downloads/" target="_blank" rel="external">https://www.visualsvn.com/downloads/</a></li>
<li>TortoiseSVN ：<a href="https://www.visualsvn.com/visualsvn/download/tortoisesvn/" target="_blank" rel="external">https://www.visualsvn.com/visualsvn/download/tortoisesvn/</a>  </li>
</ul>
<h5 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h5><ol>
<li>Subversion：按照默认安装，一直<code>next</code>即可</li>
<li>TortoiseSVN：同样按照默认安装即可，由于和资源管理器集成的，所以装后要重启。<br><strong>服务器端：Subversion（+TortoiseSVN）</strong><br><strong>客户端：TortoiseSVN</strong><a id="more"></a>
<h5 id="配置："><a href="#配置：" class="headerlink" title="配置："></a>配置：</h5></li>
<li>创建仓库，即创建一个保存你的代码历史的目录，两种方法：<ul>
<li>使用SubVersion的命令：进入命令行，CD到SubVersion/bin目录，运行命令：<code>svnadmin create D:/repository</code>。其中”D:/repository”是要创建的仓库目录名，根据你的要求自己修改。</li>
<li>使用TortoiseSVN的命令：自己新建一个目录，在上面点击右键，TortoiseSVN-&gt;Create Repository-&gt;OK，仓库建好了。</li>
</ul>
</li>
<li>仓库目录说明：<br>打开刚刚建立的仓库目录，你会发现里面有几个目录：<ul>
<li>dav目录是提供给Apache与mod_dav_svn使用的目录，让它们存储内部数据，我之前使用的版本没有这个目录</li>
<li>db目录就是所有版本控制的数据文件</li>
<li>hooks目录放置hook脚本文件的目录</li>
<li>locks用来放置Subversion文件库锁定数据的目录，用来追踪存取文件库的客户端</li>
<li>format文件是一个文本文件，里面只放了一个整数，表示当前文件库配置的版本号</li>
<li>conf目录是这个仓库的配置文件</li>
</ul>
</li>
<li>创建密码：<br>进入conf目录，你会看到三个文件：authz、passwd和svnserve.conf，这些文件就是用来管理svn的登录名和相应的用户分组、密码、权限等功能。以下分别是三个文件的配置方法。<ol>
<li>打开svnserve.conf文件作如下修改，找到以下行：<br><code>#password-db = passwd</code><br>将这三行前的“#”号去掉！</li>
<li>打开passwd文件:<br>在[users]下面增加一行，前面是用户名，后面是密码,如下：<br><code>pedro = 123456</code></li>
<li>关于authz文件，主要是做复杂的群组权限控制，我是单机个人使用，不用设置，只要上面passwd的用户名和密码就可以了</li>
</ol>
</li>
</ol>
<h5 id="测试运行："><a href="#测试运行：" class="headerlink" title="测试运行："></a>测试运行：</h5><ol>
<li>进入Subversion安装目录下的“bin”目录，按住shift键鼠标右键选择“在此处打开命令窗口选项”，输入<code>svnserve -d -r &quot;D:/repository&quot;</code>，此处 “D:/repository” 为仓库所在文件夹，可自行更改。  </li>
<li>在任意目录，右键 TortioseSVN-&gt;Repo broswer-&gt;URL 输入：<code>svn://127.0.0.1</code>如果出现密码提示，那就输入上面设置的用户名和密码。如果在Repository Broswer能看到<code>svn://127.0.0.1</code>，那就说明安装成功，大功告成了。<br><em>注：如为局域网内不同机台测试，可通过更改<code>127.0.0.1</code>为svnserver IP</em></li>
</ol>
<h5 id="创建和使用多个仓库"><a href="#创建和使用多个仓库" class="headerlink" title="创建和使用多个仓库"></a>创建和使用多个仓库</h5><p>使用上面的方法只创建了一个仓库，把所有程序都放入一个仓库看起来有点混乱，我喜欢按照项目给每个项目建立一个仓库，同一个项目的代码组件放入同一个仓库，这样看起来就清爽很多。  </p>
<h6 id="创建多个仓库："><a href="#创建多个仓库：" class="headerlink" title="创建多个仓库："></a>创建多个仓库：</h6><ol>
<li>新建一个放置项目仓库的目录，比如 “D:/repository” 。只是个目录，不要在这个目录创建仓库。</li>
<li>创建项目1的仓库：<code>svnadmin create D:/repository/Project1</code></li>
<li>创建项目2的仓库：<code>svnadmin create D:/repository/Project2</code></li>
<li>依次类推，把每个项目的仓库建立在D:/SVN目录里面就OK了。  </li>
</ol>
<h6 id="使用多个仓库："><a href="#使用多个仓库：" class="headerlink" title="使用多个仓库："></a>使用多个仓库：</h6><ol>
<li>使用 <code>svnserve -d -r &quot;D:/SVN&quot;</code>启动</li>
<li>如果你还是按照<code>svn://127.0.0.1</code>访问仓库就会发现仓库是空的。</li>
<li>要访问你的项目仓库，只要在URL后面加上仓库目录名就可以了，比如可以通过<code>svn://127.0.0.1/Project1</code>来访问项目1的仓库，里面放置的都是项目1相关的代码。用同样的方法就可以把项目仓库分开访问了  </li>
</ol>
<h5 id="将SVN作为服务运行"><a href="#将SVN作为服务运行" class="headerlink" title="将SVN作为服务运行"></a>将SVN作为服务运行</h5><p>如果不把SVN做为service运行，那你每次都要手动启动，并且总是有个命令行的黑窗口在那里。如果你关闭了命令行窗口，那SubVersion也就停止运行了。所以如果你想Windows启动后SVN自动运行，就把它设置为服务把，下面是操作步骤。<br>从命令行进入到SubVersion/bin目录，依次运行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">svnservice -install –daemon –root &quot;D:/repository&quot;</div><div class="line">sc config svnservice start= auto </div><div class="line">net start svnservice</div></pre></td></tr></table></figure></p>
<p>&emsp;<strong><em>特别注意， ‘start’ 后面必须紧跟 ‘=’，不能有空格</em></strong><br>至此，查看Windows的服务，SVNService已经启动，而且是自动运行的服务了。</p>
<h5 id="设置开机自动windows启动服务"><a href="#设置开机自动windows启动服务" class="headerlink" title="设置开机自动windows启动服务"></a>设置开机自动windows启动服务</h5><p>Subversion 从1.4版本开始，可以以windows系统服务的形式在开机时自动运行。但Subversion安装程序还不能把自己安装成windows服务，需要我们自己进行手动安装，方法如下：打开一个DOS命令窗口，执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sc create svnserve binPath= &quot;\&quot;C:/Program Files/Subversion/bin/svnserve.exe\&quot; --service --root e:/svn&quot; displayname= &quot;Subversion Repository&quot; depend= Tcpip start= auto</div></pre></td></tr></table></figure></p>
<p>其中，<code>sc</code>是windows自带的服务配置程序，<br>参数<code>binPath</code>表示svnserve可执行文件的安装路径，由于路径中的”Program Files”带有空格，因此整个路径需要用双引号引起来。而双引号本身是个特殊字符，需要进行转义，因此在路径前后的两个双引号都需要写成<code>\&quot;</code><br><code>--service</code>参数表示以windows服务的形式运行，<br><code>--root</code>指明svn repository的位置，”service”参数与”root”参数都作为binPath的一部分，因此与svnserve.exe的路径一起被包含在一对双引号当中，而这对双引号不需要进行转义。<br><code>displayname</code>表示在windows服务列表中显示的名字，<br><code>depend =Tcpip</code>表示svnserve服务的运行需要tcpip服务，start=auto表示开机后自动运行。<br>安装服务后，svnserve要等<strong>下次开机</strong>时才会自动运行。<br>若要<strong>卸载svn服务</strong>，则执行 <strong><code>sc delete svnserve</code></strong>即可</p>
]]></content>
      
        <categories>
            
            <category> SVN </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SVN </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Xen、OpenVZ、KVM三大VPS技术优劣势详解]]></title>
      <url>/2017/10/08/Xen%E3%80%81OpenVZ%E3%80%81KVM%E4%B8%89%E5%A4%A7VPS%E6%8A%80%E6%9C%AF%E4%BC%98%E5%8A%A3%E5%8A%BF%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h5 id="摘要："><a href="#摘要：" class="headerlink" title="摘要："></a>摘要：</h5><blockquote>
<p>Xen、OpenVZ、KVM三大VPS技术优劣势详解。VPS虚拟服务器是虚拟技术的产品，VPS主机常用的三大虚拟技术分别是Xen、OpenVZ与KVM，很多人都不清楚Xen、OpenVZ、KVM三种技术构建的VPS主机除价格区别外，其他具体有什么区别，这里就简单介绍Xen、OpenVZ、KVM三大VPS虚拟技术并对各自优劣势作详细解说。</p>
</blockquote>
<a id="more"></a>
<h5 id="Xen"><a href="#Xen" class="headerlink" title="Xen"></a>Xen</h5><p>&emsp;&emsp;Xen是半虚拟化技术，它并不是个真正的虚拟机，而是相当于自己运行了个内核的实例，可以自由的加载内核模块，虚拟的内存和IO，稳定而且可预测。分Xen+pv+和Xen+hvm，区别就是pv只支持linux，而hvm支持win系统。</p>
<p>&emsp;&emsp;优势：内存独占，虽然小但是保证分配的到。部分虚拟技术决定了就算是超卖也不会超太离谱。所以般的母鸡就算超了，也很少导致石头盘。当然小鸡有pt就除外了。另外就是即使内存再低也不会当掉，只是会无响应段时间。</p>
<p>&emsp;&emsp;劣势：内存小，硬盘小，带宽小（以上3点均和同价位的openvz对比）。因为没法超卖了，为了赚钱只能把这3个基本配置降下来了。还有就是供应商残次不齐，而且大部分在说xen的时候都木有明说是pv还是hvm，其实pv的性能是优于hvm的。</p>
<h5 id="OpenVZ"><a href="#OpenVZ" class="headerlink" title="OpenVZ"></a>OpenVZ</h5><p>&emsp;&emsp;OpenVZ是操作系统别的虚拟化技术，是底层操作系统上的层应用，这意味着易于理解和低权重开销，般来说也意味着更优的性能。但是OpenVZ配置起来比较灵活，给黑心服务商改低限制的机会。  </p>
<p>&emsp;&emsp;优势：现在外面卖的这种类型，许可的内存都超大，CPU也强劲，而且卖家很多，可比性也很强。性价比超高。<br>　　<br>&emsp;&emsp;劣势：超卖，没有不超卖的，导致各种石头盘，钻石盘。连带的cpu也被过度分割导致性能升值不如其标明的1/10。再有就是内存，基本上OpenVZ技术没有独占的，都是共享，别人多了你就少了，而且这种技术大的劣势就是内存下来后直接就是当机。还有开设vpn各种不方便。
　　</p>
<h5 id="KVM"><a href="#KVM" class="headerlink" title="KVM"></a>KVM</h5><p>　　</p>
<p>&emsp;&emsp;优势：和xen类似，比xen更好的点是，kvm是完全虚拟的，所以不分pv和hvm的区别，所有的kvm类+型的虚拟技术都可以装各种linux的发行版和各种win的发行版，不管供应商在主页有没有写明是否支持win，只要你配置够win运行，那就肯定可以装+的上去，只是方法的问题而已。
　　</p>
<p>&emsp;&emsp;劣势：恰恰因为kvm可以装任意类型的操作系统，导致了折腾帝甚至在128m的机器上装了win2003(上去+后直接所有的cpu和内存都用于硬盘IO 了，不明白这些人想干神马)。其结果就是所有的kvm邻居都得看你周围邻居的脸色。这么说把，一个node下只要有5、6台这种折腾帝，对不起，你的硬盘基本就是石头盘了。
　　</p>
<p>&emsp;&emsp;很多人们都比较倾向于Xen，因为它是对供应商和和客户来说都是可以接受的折衷方案。Openvz成本较高，对于服务商及客户都为不利，而kvmKVM是新兴的虚拟化项目，是是全虚拟化，需要cpu虚拟化指令支持，因此，出售KVM的VPS商家不多，且技术支持和售后服务上也比不上xen的vps主机那么成熟。</p>
]]></content>
      
        <categories>
            
            <category> VPS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> VPS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[How to setup PXE Server for NFS]]></title>
      <url>/2017/08/27/How-to-setup-PXE-Server-for-NFS/</url>
      <content type="html"><![CDATA[<h4 id="原理简介："><a href="#原理简介：" class="headerlink" title="原理简介："></a>原理简介：</h4><ul>
<li>通过PXE网卡启动，</li>
<li>从dhcp服务器获取IP和bootloader,即 pxelinux.0（DHCP server判断是否为合法的来着PXE Client 的请求后）</li>
<li>获取pxelinux.0的参数文件pxelinux.cfg/default</li>
<li>vmlinux、initrd…</li>
</ul>
<h4 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h4><ol>
<li><a href="#1">Server Environment Requirements</a></li>
<li><a href="#2">软件安装，配置PXE Server</a></li>
<li><a href="#3">编译客户端启动内核</a></li>
<li><a href="#4">自定义脚本initial解决系统启动方案</a></li>
<li><a href="#5">启动服务</a></li>
<li><p><a href="#6">运行调试</a></p>
<a id="more"></a>
<h5 id="1-Server-Environment-Requirements"><a href="#1-Server-Environment-Requirements" class="headerlink" title="1. Server Environment Requirements"></a><span id="1">1. Server Environment Requirements</span></h5></li>
<li><p>OS Requirements</p>
<ul>
<li>Redhat 6.3 </li>
<li>Redhat 6.5</li>
<li>newer</li>
</ul>
</li>
<li>Services Requirements<ul>
<li>dhcpd</li>
<li>tftp-server(Tiny FTP)</li>
<li>xinetd</li>
<li>syslinux-tftpboot</li>
</ul>
</li>
</ol>
<h5 id="2-软件安装，配置PXE-Server"><a href="#2-软件安装，配置PXE-Server" class="headerlink" title="2. 软件安装，配置PXE Server"></a><span id="2">2. 软件安装，配置PXE Server</span></h5><ul>
<li>rpm -ivh syslinux-tftpboot-xxx.x86_64.rpm</li>
<li>rpm -ivh xinetd-xxx.x86_64.rpm</li>
<li>rpm -ivh tftp-server-xxx.x86_64.rpm</li>
<li>rpm -ivh dhcp-xxxx.86_64.rpm</li>
</ul>
<p><em>在syslinux-tftpboot 软件包中,只有一个文档是我们需要的,除此之外,其他文档均可删除,这个文档就是/tftpboot/pxelinux.0, support Legacy mode boot</em></p>
<h6 id="配置-DHCP"><a href="#配置-DHCP" class="headerlink" title="配置 DHCP"></a>配置 DHCP</h6><p>在配置 DHCP 之前,首先要确定在 Server 上,需要哪个网卡来受理客户机的请求,这里假设由 eth0的网卡来提供这样的服务,那么就要设定 eth0 的地址为静态 IP,这个网卡配置的文件路径是:<code>/etc/sysconfig/network-scripts/ifcfg-eth0</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cd /etc/sysconfig/network-scripts</div><div class="line">sed -i 's/BOOTPROTO=dhcp/BOOTPROTO=static/g' ifcfg-eth0</div><div class="line">echo "IPADDR=192.168.0.20" &gt;&gt; ifcfg-eth0</div><div class="line">echo "NETMASK=255.255.255.0" &gt;&gt; ifcfg-eth0</div></pre></td></tr></table></figure>
<p>注意:如果有 HWADDR 变量,那是 eth0 的 MAC 地址,这个在读者构建是要注意,不要照抄。设置 PXE Server 名称:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo -ne "192.168.0.20 server server.domain server6 server6.domain6\n" &gt;&gt; /etc/hosts</div></pre></td></tr></table></figure>
<p>DHCP 服务启动之前首先需要一个周期文件/var/lib/dhcpd/dhcpd.leases,如果没有此档就创建之:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">touch /var/lib/dhcpd/dhcpd.leases</div></pre></td></tr></table></figure><br>DHCP 的功能是向客户机分配一个通信 IP,当然是在客户机请求的时候。用 vim 编辑/etc/dhcp/dhcpd.conf,或者按以下命令直接写入该档:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">cat &gt; /etc/dhcp/dhcpd.conf &lt;&lt; "EOF"</div><div class="line">option space PXE;</div><div class="line">option PXE.mtftp-ip                 code 1 = ip-address;</div><div class="line">option PXE.mtftp-cport              code 2 = unsigned integer 16;</div><div class="line">option PXE.mtftp-sport              code 3 = unsigned integer 16;</div><div class="line">option PXE.mtftp-tmout              code 4 = unsigned integer 8;</div><div class="line">option PXE.mtftp-delay              code 5 = unsigned integer 8;</div><div class="line">option PXE.discovery-control        code 6 = unsigned integer 8;</div><div class="line">option PXE.discovery-mcast-addr     code 7 = ip-address;</div><div class="line">option arch                         code 93 = unsigned integer 16;</div><div class="line"></div><div class="line">ddns-update-style interim;</div><div class="line">ignore client-updates;</div><div class="line">allow booting;</div><div class="line">allow bootp;</div><div class="line">subnet 192.168.0.0 netmask 255.255.0.0 &#123;</div><div class="line">DHCPDARGS=eth0;### 指定 eth0 网卡做 DHCP 的服务,其他 PXE Server 网卡不受理客户机的 DHCP 请求。</div><div class="line"></div><div class="line">option routers             192.168.0.1;</div><div class="line">option broadcast-address   192.168.255.255;</div><div class="line">option subnet-mask         255.255.0.0;</div><div class="line">option domain-name-servers 192.168.0.20;</div><div class="line">option nis-domain "domain.org";</div><div class="line">option domain-name "domain.org";</div><div class="line">option time-offset        -18000; # Eastern Standard Time</div><div class="line">range dynamic-bootp       192.168.0.30    192.168.3.252;</div><div class="line">class "pxeclients" &#123;</div><div class="line">match if substring (option vendor-class-identifier,0,9)="PXEClient";</div><div class="line">next-server 192.168.0.20;</div><div class="line">if option arch = 00:07 &#123;</div><div class="line">filename "UEFI/BOOT/BOOTX64.efi";</div><div class="line">&#125; else &#123;</div><div class="line">filename "Legacy/pxelinux.0";</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">default-lease-time 1800;</div><div class="line">max-lease-time 3600;</div><div class="line">&#125;</div><div class="line">EOF</div></pre></td></tr></table></figure></p>
<h6 id="PXE-Server-端配置-TFTP"><a href="#PXE-Server-端配置-TFTP" class="headerlink" title="PXE Server 端配置 TFTP"></a>PXE Server 端配置 TFTP</h6><p>TFTP 在 PXE 远程启动过程中提供档下载的服务,所有的档下载都是通过 TFTP 完成。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">cat &gt; /etc/xinetd.d/tftp &lt;&lt; "EOF"</div><div class="line">service tftp</div><div class="line">&#123;</div><div class="line">socket_type = dgram</div><div class="line">protocols = udp</div><div class="line">wait = yes</div><div class="line">user = root</div><div class="line">server = /usr/sbin/in.tftpd</div><div class="line">server_args = -s /tftpboot -vvv</div><div class="line">disable = no</div><div class="line">per_source = 22</div><div class="line">cps = 100 2</div><div class="line">flags= IPv4</div><div class="line">&#125;</div><div class="line">EOF</div></pre></td></tr></table></figure></p>
<h6 id="构建客户端文件系统"><a href="#构建客户端文件系统" class="headerlink" title="构建客户端文件系统"></a>构建客户端文件系统</h6><p>到这里,建议操作人员自己定制安装一个 Linux 系统,把需要的软件包都装上去,再把安装好的 Linux 系统按照上面的操作去构建一个被挂载文件系统。这样给客户端挂载的文件系统就要小得多。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">mkdir -p /tftpboot/pxeboot/&#123;root,home,var,opt,dev,sys,proc,tmp,mnt,media,misc,net,srv,log&#125;</div><div class="line">mkdir -p /tftpboot/&#123;pxeboot,Legacy,UEFI &#125;</div><div class="line">cd /tftpboot/pxeboot</div><div class="line">chmod 777 tmp</div><div class="line">cp -fr /bin ./</div><div class="line">cp -fr /sbin ./</div><div class="line">cp -fr /usr ./</div><div class="line">cp -fr /etc ./</div><div class="line">cp -fr /lib ./</div><div class="line">cp -fr /lib64 ./</div><div class="line">rm -fr lib/modules/*</div><div class="line">cp -fr /root/.bashrc root/</div><div class="line">cp -fr /root/.bash_profile root/</div><div class="line">if [ -f etc/dhcpd.conf ]; then</div><div class="line">echo "" &gt; etc/dhcpd.conf</div><div class="line">rm etc/grub.conf -fr</div><div class="line">sed -i 's/SELINUX=enforcing/SELINUX=disabled/g' etc/selinux/config</div><div class="line">fi</div><div class="line">sed -i '/\&lt;order\&gt;/D' etc/host.conf</div><div class="line">echo 'reorder on' &gt;&gt; etc/host.conf</div><div class="line">if [ -f etc/xinetd.d/tftp ]; then</div><div class="line">TFTPDIS=`grep "disable" -R etc/xinetd.d/tftp |sed 's/no/yes/g'`</div><div class="line">ORI=`grep "disable" -R etc/xinetd.d/tftp`</div><div class="line">if [[ ! -z $TFTPDIS &amp;&amp; ! -z $ORI ]]; then</div><div class="line">sed -i "s/$ORI/$TFTPDIS/" etc/xinetd.d/tftp</div><div class="line">fi</div><div class="line">fi</div></pre></td></tr></table></figure></p>
<h6 id="准备测试程序包"><a href="#准备测试程序包" class="headerlink" title="准备测试程序包"></a>准备测试程序包</h6><p>程序放到 <code>/tftpboot/pxeboot/usr/local/XXXXXX</code></p>
<h6 id="设置客户机挂载的文件系统"><a href="#设置客户机挂载的文件系统" class="headerlink" title="设置客户机挂载的文件系统"></a>设置客户机挂载的文件系统</h6><p>配置这一项的目的是允许客户机挂载 PXE Server 文件目录,这里允许客户端得到这文件系统的完全控制权。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cat &gt; /etc/exports &lt;&lt; "EOF"</div><div class="line">/tftpboot/pxeboot *(rw,all_squash,anonuid=0,anongid=0)</div><div class="line">EOF</div></pre></td></tr></table></figure></p>
<h6 id="客户机文件系统配置"><a href="#客户机文件系统配置" class="headerlink" title="客户机文件系统配置"></a>客户机文件系统配置</h6><p>客户端启动时对文件系统挂载列表:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">cat &gt; /tftpboot/pxeboot/etc/fstab &lt;&lt; "EOF"</div><div class="line">192.168.0.20:/tftpboot/pxeboot /   nfs  nolock,retry=1            1 1</div><div class="line">tmpfs  /dev/shm           tmpfs     defaults                0 0</div><div class="line">tmpfs  /tmp               tmpfs     defaults                0 0 </div><div class="line">/usr/local/Foxconn               tmpfs     defaults                0 0 </div><div class="line">devpts /dev/pts           devpts    gid=5,mode=620          0 0</div><div class="line">sysfs  /sys               sysfs   defaults                  0 0</div><div class="line">proc   /proc              proc    defaults                  0 0</div><div class="line">EOF</div></pre></td></tr></table></figure></p>
<h6 id="对启动级别和显示终端的设定"><a href="#对启动级别和显示终端的设定" class="headerlink" title="对启动级别和显示终端的设定"></a>对启动级别和显示终端的设定</h6><p>用 vim 编辑<code>/tftpboot/pxeboot/etc/inittab</code>,或者通过以下命令设定启动级别:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -i 's#id:5:initdefault:#id:3:initdefault:#g' /tftpboot/pxeboot/etc/inittab</div></pre></td></tr></table></figure><br>设定后的启动级别是从第 3 级启动,也就是文本模式启动</p>
<h5 id="3-编译客户端启动内核"><a href="#3-编译客户端启动内核" class="headerlink" title="3. 编译客户端启动内核"></a><span id="3">3. 编译客户端启动内核</span></h5><p>编译客户端启动所用的内核,要注意的地方:</p>
<ul>
<li>网络在内核启动过程中的支持</li>
<li>块设备在内核中的支持</li>
<li>支持远程 PXE 启动的网卡驱动不要作为独立的模块编译</li>
<li>网络文件系统的支持</li>
</ul>
<p>以上提到的只是最基本的支持,需要根据自己的需要对内核做实际的配置。<br>内核源代码可以从网页 <a href="http://www.kernel.org/pub/linux/kernel/" target="_blank" rel="external">http://www.kernel.org/pub/linux/kernel/</a> 下载。</p>
<h6 id="解压内核代码包"><a href="#解压内核代码包" class="headerlink" title="解压内核代码包"></a>解压内核代码包</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tar -xzvf linux-3.18.1.tar.gz -C /home</div><div class="line">cd /home</div></pre></td></tr></table></figure>
<h6 id="修改内核版本信息"><a href="#修改内核版本信息" class="headerlink" title="修改内核版本信息"></a>修改内核版本信息</h6><p>给你的 kernel 取个名:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd /home/linux-3.18.1</div><div class="line">EXTVER=`grep '^EXTRAVERSION' -R Makefile`</div><div class="line">sed -i "s/$EXTVER/EXTRAVERSION = -3.18.1 XXX/" Makefile ####可自定义</div></pre></td></tr></table></figure><br>编译内核之前 首先要配置内核 选择需要的模块 按照前面所讲到的顺序我们一步步来配置内核。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make menuconfig</div></pre></td></tr></table></figure></p>
<p>######支持模块自动加载</p>
<pre><code>[*] Enable loadable module support ---&gt;
[*] Forced module loading
[*] Module unloading
[ ] Forced module unloading
[*] Module versioning support
[*] Source checksum for all modules
</code></pre><h6 id="网络在内核启动过程中的支持"><a href="#网络在内核启动过程中的支持" class="headerlink" title="网络在内核启动过程中的支持"></a>网络在内核启动过程中的支持</h6><pre><code>-*- Networking support ---&gt;
Networking options
---&gt;
[*] TCP/IP networking
[*] IP: multicasting
[*] IP: advanced router
[ ] FIB TRIE statistics
[*] IP: policy routing
[*] IP: equal cost multipath
[*] IP: verbose route monitoring
[*]
IP: kernel level autoconfiguration
[*] IP: DHCP support
[*] IP: BOOTP support
[*] IP: RARP support
</code></pre><h6 id="块设备和网卡驱动在内核中的支持"><a href="#块设备和网卡驱动在内核中的支持" class="headerlink" title="块设备和网卡驱动在内核中的支持"></a>块设备和网卡驱动在内核中的支持</h6><pre><code>Device Drivers ---&gt;
[*] Block devices
&lt;*&gt;
---&gt;
RAM block device support
[*] Network device support ---&gt;
[*]
Ethernet (1000 Mbit) ---&gt;
&lt;M&gt; Intel(R) PRO/1000 PCI-Express Gigabit Ethernet support
&lt;*&gt; Intel(R) 82575/82576 PCI-Express Gigabit Ethernet support
</code></pre><p>支持远程 PXE 启动的网卡驱动不要作为独立的模块编译,本文的描述是基于 Intel网卡来实现的,因此,本文在这里只针对 Intel 82575/82576 网卡做了配置。如果你需要对其他网卡驱动设置 你可以找到对于模块选中为“&lt;*&gt;”进行编译</p>
<h6 id="网络文件系统的支持"><a href="#网络文件系统的支持" class="headerlink" title="网络文件系统的支持"></a>网络文件系统的支持</h6><pre><code>File systems ---&gt;
&lt;*&gt; Second extended fs support
...
&lt;*&gt; Ext3 journalling file system support
...
&lt;*&gt; The Extended 4 (ext4) filesystem
...
[*] Network File Systems ---&gt;
&lt;*&gt;
[*]
NFS client support
NFS client support for NFS version 3
[*]
[*]
NFS client support for the NFSv3 ACL protocol extension
NFS client support for NFS version 4
[*]
[*]
NFS client support for NFSv4.1 (EXPERIMENTAL)
Root file system on NFS
...
&lt;*&gt;
NFS server support
[*] Include support for deprecated syscall interface to NFSD
-*- NFS server support for NFS version 3
[*]
[*]
NFS server support for the NFSv3 ACL protocol extension
NFS server support for NFS version 4 (EXPERIMENTAL)
...
&lt;M&gt;
CIFS support (advanced network filesystem, SMBFS successor)
</code></pre><p>对网络文件系统的支持只是文件系统的一部份,不是全部,例如 ext2,ext3 等等文件系统也是要支持的。新编的内核不需要任何虚拟模块的支持,读者可以自行配置启动内核。配置内核完了之后,开始编译内核源代码,这要花些时间。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">make</div><div class="line">make modules</div><div class="line">make modules_install</div><div class="line">make install</div></pre></td></tr></table></figure><br>到这里,最好是重启机器,验证新编译成功的代码是不是能启动。如果能用新的内核启动机器,再将安装的内核拷贝到/tftpboot,将设备驱动目录都拷贝到/tftpboot/pxeboot/lib/modules 目录下。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">d /boot/</div><div class="line">cp -fr</div><div class="line">vmlinuz-3.18.1 /tftpboot</div><div class="line">cd /lib/modules</div><div class="line">cp -fr 3.18.1 /tftpboot/pxeboot/lib/modules</div></pre></td></tr></table></figure></p>
<h5 id="4-自定义脚本initial解决系统启动方案"><a href="#4-自定义脚本initial解决系统启动方案" class="headerlink" title="4. 自定义脚本initial解决系统启动方案"></a><span id="4">4. 自定义脚本initial解决系统启动方案</span></h5><h6 id="Initial-定义"><a href="#Initial-定义" class="headerlink" title="Initial 定义"></a>Initial 定义</h6><p>Linux 系统从 kernel 转向 rc.sysinit 脚本前,我们可以指定自己的初始化脚本 initial,让系统去执行这个脚本。系统在调用 RAMDISK 方案中的 initial 或者调用自定义的 initial 脚本过程是一样的。你可以根据自己的需要去设计这个脚本。这里我们要实现的是将 UUT 客户端的/var 目录建立完善。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">cat &gt; /tftpboot/pxeboot/etc/initial &lt;&lt; "EOF"</div><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line">mount -t tmpfs tmpfs /var</div><div class="line">mkdir -p /var/spool/&#123;anacron,clientmqueue&#125;</div><div class="line">mkdir -p /var/&#123;tmp,log,cache,local,etc&#125;</div><div class="line">mkdir -p /var/log/sa</div><div class="line">mkdir -p /var/lock/subsys</div><div class="line">mkdir -p /var/empty/sshd/etc</div><div class="line">mkdir -p /var/lib/nfs/statd/&#123;sm,sm.bak&#125;</div><div class="line">mkdir -p /var/lib/nfs/rpc_pipefs</div><div class="line">mkdir -p /var/lib/&#123;dbus,rpm&#125;</div><div class="line">- 12 -</div><div class="line">mkdir -p /var/run/&#123;dbus,netreport,udev,systemd,user,mount&#125;</div><div class="line">mkdir -p /var/run/udev/&#123;data,rules.d,links,tags,watch&#125;</div><div class="line">mkdir -p /var/run/systemd/readahead</div><div class="line">mkdir -p /var/spool/&#123;clientmqueue,at&#125;</div><div class="line">touch /var/spool/at/.SEQ</div><div class="line">exec /sbin/init 3</div><div class="line">EOF</div><div class="line">chmod +x /tftpboot/pxeboot/etc/initial</div></pre></td></tr></table></figure></p>
<h6 id="启动文件-bootstrap-配置"><a href="#启动文件-bootstrap-配置" class="headerlink" title="启动文件 bootstrap 配置"></a>启动文件 bootstrap 配置</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">cat &gt; /tftpboot/ Legacy/pxelinux.cfg/default &lt;&lt; "EOF"</div><div class="line">default PXEServer</div><div class="line">prompt 1</div><div class="line">timeout 5</div><div class="line">label PXEServer</div><div class="line">hiddenmenu</div><div class="line">title PXE Diagnostics Linux x86_x64</div><div class="line">kernel vmlinuz-3.18.1</div><div class="line">append init=/etc/initial lang=en_US keymap=us root=/dev/nfs nfsroot=192.168.0.20:/tftpboot/pxeboot/ ip=dhcp </div><div class="line">EOF</div></pre></td></tr></table></figure>
<h5 id="5-启动服务"><a href="#5-启动服务" class="headerlink" title="5. 启动服务"></a><span id="5">5. 启动服务</span></h5><p>运行<code>setup</code>命令关掉防火墙和SeLinux：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@pxeserver ~]# setup</div><div class="line">选中Firewall configuration，选中Run Tool，回车确认；</div><div class="line">Security Level: ( ) Enabled(*) Disabled</div><div class="line">SELinux: Enforcing</div><div class="line">Permissive</div><div class="line">Disabled</div></pre></td></tr></table></figure><br>启动服务进程:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">service iptables stop</div><div class="line">service dhcpd restart</div><div class="line">service nfs restart</div><div class="line">service xinetd restart</div></pre></td></tr></table></figure></p>
<h5 id="6-运行调试"><a href="#6-运行调试" class="headerlink" title="6. 运行调试"></a><span id="6">6. 运行调试</span></h5><ol>
<li>插入键盘鼠标会弹出设备的输入输出msg信息<br>可以设定printk级别到最高忽略这些信息<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo -n 0 0 0 0 &gt; /proc/sys/kernel/printk</div></pre></td></tr></table></figure></li>
<li>客户端获取不到 IP<ul>
<li>检查 DHCP 服务是否已经开启(service dhcpd status)。</li>
<li>检查网络情况,可以将第三方计算机与 server 主机相连,试着去获取 IP,如果得不到 IP,DHCP server出了问题;如果可以获得 IP,网络有问题;如果有部分客户端分到 IP,部分没分到 IP,可能是 IP POOL中的 IP 已经耗尽,这是最好清理一下 DHCP 日志,然后再重启 DHCP:<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rm -fr /var/lib/dhcpd/dhcpd.leases~</div><div class="line">echo &gt; /var/lib/dhcpd/dhcpd.leases</div><div class="line">service dhcpd restart</div></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> PXEServer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于Mongodb的WechatRobot群聊记录功能]]></title>
      <url>/2017/07/30/%E5%9F%BA%E4%BA%8EMongodb%E7%9A%84WechatRobot%E7%BE%A4%E8%81%8A%E8%AE%B0%E5%BD%95%E5%8A%9F%E8%83%BD/</url>
      <content type="html"><![CDATA[<h4 id="基于Mongodb的WechatRobot群聊记录功能"><a href="#基于Mongodb的WechatRobot群聊记录功能" class="headerlink" title="基于Mongodb的WechatRobot群聊记录功能"></a>基于Mongodb的WechatRobot群聊记录功能</h4><blockquote>
<p>实验目的：实现类似下图效果的微信签到，群聊数据记录功能</p>
</blockquote>
<img src="/2017/07/30/基于Mongodb的WechatRobot群聊记录功能/result.jpg" alt="result image" title="result image">
<h5 id="开发步骤："><a href="#开发步骤：" class="headerlink" title="开发步骤："></a>开发步骤：</h5><pre><code>1. Mongodb数据库搭建
2. 插入、查询命令测试
3. 功能函数编写和测试
4. 主函数调用效果监测
</code></pre><a id="more"></a>
<h5 id="Mongodb数据库搭建"><a href="#Mongodb数据库搭建" class="headerlink" title="Mongodb数据库搭建"></a>Mongodb数据库搭建</h5><p>&#160; &#160; &#160; &#160;Mongodb基础搭建和使用教程可以点击<a href="https://www.runoob.com/mongodb/mongodb-tutorial.html" target="_blank" rel="external">菜鸟教程</a>（没收广告费）进行学习，教程内容通俗易懂老少咸宜，适合初学者学习（真没有收广告费）╮(╯▽╰)╭</p>
<h5 id="插入、查询命令测试"><a href="#插入、查询命令测试" class="headerlink" title="插入、查询命令测试"></a>插入、查询命令测试</h5><p>&#160; &#160; &#160; &#160;关于群签到和聊天数据统计功能会用到的基础命令有</p>
<ol>
<li><code>db.xxx.save</code></li>
<li><code>db.xxx.update</code></li>
<li><code>db.xxx.find</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&gt; show dbs</div><div class="line">admin   0.078GB</div><div class="line">local   0.078GB</div><div class="line">nodedb  0.078GB</div><div class="line">test    0.078GB</div><div class="line">wechat  0.078GB</div><div class="line">&gt; use test</div><div class="line">switched to db test</div><div class="line">&gt; db.wechat.save(&#123;&quot;name&quot;:&quot;Pedro&quot;,&quot;group&quot;:&quot;group1&quot;,&quot;number&quot;:1&#125;)</div><div class="line">WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)</div><div class="line">&gt; db.wechat.save(&#123;&quot;name&quot;:&quot;Qiqi&quot;,&quot;group&quot;:&quot;group1&quot;,&quot;number&quot;:2&#125;)</div><div class="line">WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)</div><div class="line">&gt; db.wechat.find(&#123;&quot;group&quot;:&quot;group1&quot;&#125;)</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;597e066d4b3188da1b178cd0&quot;), &quot;name&quot; : &quot;Pedro&quot;, &quot;group&quot; : &quot;group1&quot;, &quot;number&quot; : 1 &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;597e06854b3188da1b178cd1&quot;), &quot;name&quot; : &quot;Qiqi&quot;, &quot;group&quot; : &quot;group1&quot;, &quot;number&quot; : 2 &#125;</div><div class="line">&gt; db.wechat.update(&#123;&quot;name&quot;:&quot;Pedro&quot;&#125;,&#123; &quot;$inc&quot; : &#123;&quot;number&quot;:1&#125;&#125;)</div><div class="line">WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;)</div><div class="line">&gt; db.wechat.find(&#123;&quot;name&quot;:&quot;Pedro&quot;&#125;)</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;597e066d4b3188da1b178cd0&quot;), &quot;name&quot; : &quot;Pedro&quot;, &quot;group&quot; : &quot;group1&quot;, &quot;number&quot; : 2 &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>也许你会纠结为什么此处使用<code>save</code>而非<code>insert</code>，其实两者在此处并没有区别，可以通用。关于两者的细微区别在此稍作介绍：<br>   <a href="http://blog.csdn.net/xiaojin21cen/article/details/40480609" target="_blank" rel="external"><strong>若新增的数据中存在主键 ，insert() 会提示错误，而save() 则更改原来的内容为新内容</strong>。</a>如：已存在数据：  <code>{_id : 1, &quot; name &quot; : &quot; n1 &quot; }</code>，再次进行插入操作时，<br><code>insert({_id : 1, &quot; name &quot; : &quot; n2 &quot; })</code>    会报主键重复的错误提示<br><code>save({ _id : 1, &quot; name &quot; : &quot; n2 &quot; })</code>    会把 n1 修改为  n2  。</p>
</blockquote>
<h5 id="功能函数编写和测试"><a href="#功能函数编写和测试" class="headerlink" title="功能函数编写和测试"></a>功能函数编写和测试</h5><ol>
<li>关于签到功能设计，需要确定要插入数据库的数据格式，根据与群签到相关的数据，可以设计数据的内容包括：<strong>用户名、群名称、个人签到总次数、签到日期（貌似非必须）</strong>，即：<code>{&quot;name&quot;:name,&quot;group&quot;:group,&quot;time&quot;:1,&quot;date&quot;:datetime.datetime.now().strftime(&#39;%b-%d-%y&#39;)}</code></li>
<li>由于要实现图中“第n个签到”的功能，还需要新建一条数据用来存储当日已签到总人数，其内容包括：<strong>特殊数据标记（用于区分一个collection下此数据与其他数据区别，便于查找），群名称，群签到总次数，日期</strong>，即：<code>{&quot;daily_report&quot;:&quot;Yes&quot;,&quot;date&quot;:datetime.datetime.now().strftime(&#39;%b-%d-%y&#39;),&quot;number&quot;:1,&quot;group&quot;:group}</code></li>
<li>当日发言总数的数据结构相对比较简单：<strong>特殊数据标记，群名称，日期，总发言数</strong>，即<code>{&quot;daily_Sum&quot;:&quot;Yes&quot;,&quot;date&quot;:datetime.datetime.now().strftime(&#39;%b-%d-%y&#39;),&quot;today&quot;:1,&quot;group&quot;:group}</code></li>
<li>关于当日发言数排行的实现，首先需要记录个人在单个群组的聊天次数，此时需要的数据结构为：<strong>特殊数据标记，日期，发言数，群名称，用户名</strong>，即<code>{&quot;per_daily&quot;:&quot;Yes&quot;,&quot;date&quot;:datetime.datetime.now().strftime(&#39;%b-%d-%y&#39;),&quot;number&quot;:1,&quot;group&quot;:group,&quot;name&quot;:name}</code></li>
<li>实现了数据采集，最后要做的就是数据的分析和排序，在本例的源码的<code>listGroup</code>函数中使用了<code>find</code>的<code>limit</code>、<code>sort</code>方法实现：<code>perlogs.find({&quot;date&quot;:date,&quot;group&quot;:group}).limit(5).sort([(&quot;number&quot;,-1)])</code></li>
<li>最后在我们的robot中的群组消息处理函数处调用这个模块的函数就可以了，大功告成！</li>
</ol>
<blockquote>
<p>附上文中所提及函数的部分源码，完整源码已更新到<a href="https://github.com/pedroqin/wechat_robot" target="_blank" rel="external">我的GitHub</a>中，有兴趣的请<a href="https://github.com/pedroqin/wechat_robot" target="_blank" rel="external">点击跳转</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment">#coding:utf-8</span></div><div class="line"></div><div class="line"><span class="comment"># sign in num , return :your signIn number and total signIn number</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">signIn</span><span class="params">(name,group)</span>:</span></div><div class="line">    string=posts.find_one(&#123;<span class="string">"name"</span>:name,<span class="string">"group"</span>:group&#125;)</div><div class="line"><span class="comment">#    print "+++",string,"+++"</span></div><div class="line">    <span class="keyword">if</span>  string  != <span class="keyword">None</span>:</div><div class="line">        <span class="keyword">if</span> string[<span class="string">"date"</span>] != datetime.datetime.now().strftime(<span class="string">'%b-%d-%y'</span>):</div><div class="line">             posts.update(&#123;<span class="string">"name"</span>:name,<span class="string">"group"</span>:group&#125;,&#123; <span class="string">"$set"</span> : &#123;<span class="string">"date"</span>:datetime.datetime.now().strftime(<span class="string">'%b-%d-%y'</span>)&#125;&#125;,<span class="keyword">True</span>,<span class="keyword">False</span>)</div><div class="line">             posts.update(&#123;<span class="string">"name"</span>:name,<span class="string">"group"</span>:group&#125;,&#123; <span class="string">"$inc"</span> : &#123;<span class="string">"time"</span>: <span class="number">1</span>&#125;&#125;,<span class="keyword">True</span>,<span class="keyword">False</span>)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">             <span class="keyword">return</span> <span class="string">"False"</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        new_post=&#123;<span class="string">"name"</span>:name,<span class="string">"group"</span>:group,<span class="string">"time"</span>:<span class="number">1</span>,<span class="string">"date"</span>:datetime.datetime.now().strftime(<span class="string">'%b-%d-%y'</span>)&#125;</div><div class="line">        posts.save(new_post)</div><div class="line">    <span class="keyword">return</span> [posts.find_one(&#123;<span class="string">"name"</span>:name,<span class="string">"group"</span>:group&#125;)[<span class="string">"time"</span>],daily(group)]</div><div class="line"><span class="comment">#</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">daily</span><span class="params">(group)</span>:</span></div><div class="line">    number=glogs.find_one(&#123;<span class="string">"daily_report"</span>:<span class="string">"Yes"</span>,<span class="string">"group"</span>:group,<span class="string">"date"</span>:datetime.datetime.now().strftime(<span class="string">'%b-%d-%y'</span>)&#125;)</div><div class="line">    <span class="keyword">if</span> number == <span class="keyword">None</span>:</div><div class="line">        new=&#123;<span class="string">"daily_report"</span>:<span class="string">"Yes"</span>,<span class="string">"date"</span>:datetime.datetime.now().strftime(<span class="string">'%b-%d-%y'</span>),<span class="string">"number"</span>:<span class="number">1</span>,<span class="string">"group"</span>:group&#125;</div><div class="line">        glogs.save(new)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        glogs.update(&#123;<span class="string">"daily_report"</span>:<span class="string">"Yes"</span>,<span class="string">"group"</span>:group,<span class="string">"date"</span>:datetime.datetime.now().strftime(<span class="string">'%b-%d-%y'</span>)&#125;,&#123; <span class="string">'$inc'</span> :&#123;<span class="string">"number"</span>: <span class="number">1</span>&#125;&#125;)</div><div class="line">    <span class="keyword">return</span> glogs.find_one(&#123;<span class="string">"daily_report"</span>:<span class="string">"Yes"</span>,<span class="string">"group"</span>:group,<span class="string">"date"</span>:datetime.datetime.now().strftime(<span class="string">'%b-%d-%y'</span>)&#125;)[<span class="string">"number"</span>]</div><div class="line"></div><div class="line"><span class="comment">#return today Msg total num, and accumulate today Msg num</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">dailyLogMsg</span><span class="params">(group)</span>:</span></div><div class="line">    allMsg=glogs.find_one(&#123;<span class="string">"daily_Sum"</span>:<span class="string">"Yes"</span>,<span class="string">"group"</span>:group,<span class="string">"date"</span>:datetime.datetime.now().strftime(<span class="string">'%b-%d-%y'</span>)&#125;)</div><div class="line">    <span class="keyword">if</span> allMsg == <span class="keyword">None</span>:<span class="comment"># create today's log</span></div><div class="line">        new=&#123;<span class="string">"daily_Sum"</span>:<span class="string">"Yes"</span>,<span class="string">"date"</span>:datetime.datetime.now().strftime(<span class="string">'%b-%d-%y'</span>),<span class="string">"today"</span>:<span class="number">1</span>,<span class="string">"group"</span>:group&#125;</div><div class="line">        glogs.save(new)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        glogs.update(&#123;<span class="string">"daily_Sum"</span>:<span class="string">"Yes"</span>,<span class="string">"group"</span>:group,<span class="string">"date"</span>:datetime.datetime.now().strftime(<span class="string">'%b-%d-%y'</span>)&#125;,&#123; <span class="string">'$inc'</span> :&#123;<span class="string">"today"</span>: <span class="number">1</span>&#125;&#125;)</div><div class="line">    <span class="keyword">return</span> glogs.find_one(&#123;<span class="string">"daily_Sum"</span>:<span class="string">"Yes"</span>,<span class="string">"group"</span>:group,<span class="string">"date"</span>:datetime.datetime.now().strftime(<span class="string">'%b-%d-%y'</span>)&#125;)[<span class="string">"today"</span>]<span class="comment">#return today 's sum for create the picture</span></div><div class="line"></div><div class="line"><span class="comment">#accumulate everyone's total Msg num</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">perNum</span><span class="params">(name,group)</span>:</span></div><div class="line">    perNum=perlogs.find_one(&#123;<span class="string">"per_daily"</span>:<span class="string">"Yes"</span>,<span class="string">"name"</span>:name,<span class="string">"group"</span>:group,<span class="string">"date"</span>:datetime.datetime.now().strftime(<span class="string">'%b-%d-%y'</span>)&#125;)</div><div class="line">    <span class="keyword">if</span> perNum == <span class="keyword">None</span>:</div><div class="line">        new=&#123;<span class="string">"per_daily"</span>:<span class="string">"Yes"</span>,<span class="string">"date"</span>:datetime.datetime.now().strftime(<span class="string">'%b-%d-%y'</span>),<span class="string">"number"</span>:<span class="number">1</span>,<span class="string">"group"</span>:group,<span class="string">"name"</span>:name&#125;</div><div class="line">        perlogs.save(new)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        perlogs.update(&#123;<span class="string">"per_daily"</span>:<span class="string">"Yes"</span>,<span class="string">"group"</span>:group,<span class="string">"name"</span>:name,<span class="string">"date"</span>:datetime.datetime.now().strftime(<span class="string">'%b-%d-%y'</span>)&#125;,&#123; <span class="string">'$inc'</span> :&#123;<span class="string">"number"</span>: <span class="number">1</span>&#125;&#125;)</div><div class="line">    <span class="keyword">return</span> perlogs.find_one(&#123;<span class="string">"per_daily"</span>:<span class="string">"Yes"</span>,<span class="string">"name"</span>:name,<span class="string">"group"</span>:group,<span class="string">"date"</span>:datetime.datetime.now().strftime(<span class="string">'%b-%d-%y'</span>)&#125;)[<span class="string">"number"</span>]</div><div class="line"></div><div class="line"><span class="comment">#list top 5 people who had sent most msg yesterday</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">listGroup</span><span class="params">(date,group)</span>:</span></div><div class="line">    result=perlogs.find(&#123;<span class="string">"date"</span>:date,<span class="string">"group"</span>:group&#125;).limit(<span class="number">5</span>).sort([(<span class="string">"number"</span>,<span class="number">-1</span>)])</div><div class="line">    <span class="keyword">return</span> result</div><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Wechat </tag>
            
            <tag> Python2.6 </tag>
            
            <tag> Mongodb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Wechat_linux_Shell]]></title>
      <url>/2017/07/26/Wechat_linux_Shell/</url>
      <content type="html"><![CDATA[<h4 id="做這些實驗的初衷"><a href="#做這些實驗的初衷" class="headerlink" title="做這些實驗的初衷"></a>做這些實驗的初衷</h4><p>&#160; &#160; &#160; &#160;樹莓派自從買回來已經吃灰半年有餘，正巧最近在看python，本著練手的初衷開始對樹莓派進行“廢物利用”，下面開始正題~</p>
<hr>
<h6 id="本實驗主要指導來自於知乎這篇文當：当Python遇上微信，可以这么玩"><a href="#本實驗主要指導來自於知乎這篇文當：当Python遇上微信，可以这么玩" class="headerlink" title="本實驗主要指導來自於知乎這篇文當：当Python遇上微信，可以这么玩"></a>本實驗主要指導來自於知乎這篇文當：<a href="https://zhuanlan.zhihu.com/p/26514576" target="_blank" rel="external">当Python遇上微信，可以这么玩</a></h6><a id="more"></a>
<h4 id="實驗環境"><a href="#實驗環境" class="headerlink" title="實驗環境:"></a>實驗環境:</h4><blockquote>
<p>Respberry Pi + python</p>
<h4 id="摘要："><a href="#摘要：" class="headerlink" title="摘要："></a>摘要：</h4><p>基於python下itchat庫實現Wechat robot,用python修飾器對robot回復功能進行消息判斷和消息處理，實現對Respberry發送命令以及接收命令運行結果</p>
</blockquote>
<h4 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h4><ol>
<li>環境架設</li>
</ol>
<p>&#160; &#160; &#160; &#160;本文主要測試是基於RespberryPi下Ubuntu16.4，當然你可以在在虛擬機以及電腦的linux系統上進行。Python版本是2.6，暫時沒有測試3.0版本。另外需<code>pip install itchat</code>或者<a href="https://github.com/littlecodersh/ItChat/tree/robot" target="_blank" rel="external">點這裡</a>下載itchat后解壓<code>python setup.py install</code> 導入</p>
<ol>
<li><p>Wechat robot</p>
<ol>
<li>既然是Wechat robot，那就加個簡單的對話功能，實現人機對話，此處實驗採用的是圖靈機器人，大家可以<a href="http://www.tuling123.com/" target="_blank" rel="external">點擊這裡</a>進行賬號註冊,<a href="http://www.tuling123.com/help/help_center.jhtml?nav=doc" target="_blank" rel="external">點擊查看幫助文檔</a>。基礎的機器人服務是免費的。通過得到的key值，將本地的微信消息與圖靈連通，實現機器人模擬會話。</li>
<li>基於前一條功能，最基本的Wechat Robot已經完成，接下來要完成的就是做一個基於robot的類似簡版<a href="https://baike.baidu.com/item/Xshell/5659054?fr=aladdin" target="_blank" rel="external">Xshell</a>工具，可以通過微信發送命令到robot所在系統并執行，實現對linux主機的簡易控制。所以，本功能的實現主體是，將微信接收到的命令通過python調用相應函數實現命令的執行，並接受返回值等信息。在本案例中選用commands的子進程函數getstatusoutput()函數實現，并且帶有返回值以及返回信息。</li>
<li>後續開發中，會通過itchat包中對發送接收信息的支持，可以實現發送接收文件到linux主機。 </li>
</ol>
</li>
</ol>
<h5 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h5><blockquote>
<p>基於itchat實現的Wechat robot 本質上為網頁版微信，登錄方式等與網頁版微信一致</p>
</blockquote>
<h5 id="附簡易代碼做參考"><a href="#附簡易代碼做參考" class="headerlink" title="附簡易代碼做參考"></a>附簡易代碼做參考</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> itchat</div><div class="line"><span class="keyword">import</span> requests</div><div class="line"><span class="keyword">import</span> commands</div><div class="line"><span class="keyword">from</span> itchat.content <span class="keyword">import</span> *</div><div class="line"></div><div class="line">KEY = <span class="string">'6d1f45613b434325b1b823f19fca5a91'</span></div><div class="line"><span class="comment">#this is the tuling robot,get the wechat msg you received,and send you the response</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_response</span><span class="params">(msg)</span>:</span></div><div class="line">    apiUrl = <span class="string">'http://www.tuling123.com/openapi/api'</span></div><div class="line">    data = &#123;</div><div class="line">        <span class="string">'key'</span>    : KEY,</div><div class="line">        <span class="string">'info'</span>   : msg,</div><div class="line">        <span class="string">'userid'</span> : <span class="string">'Pedro-wechat-robot'</span>,</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        r = requests.post(apiUrl, data=data).json()</div><div class="line">        <span class="keyword">return</span> r.get(<span class="string">'text'</span>)</div><div class="line">    <span class="keyword">except</span>:</div><div class="line">        <span class="keyword">return</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@itchat.msg_register(itchat.content.TEXT)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">tuling_reply</span><span class="params">(msg)</span>:</span></div><div class="line"><span class="comment">#用以區分普通消息與command，已*開頭為commands</span></div><div class="line">    <span class="keyword">if</span> msg[<span class="string">'Text'</span>].startswith(<span class="string">'*'</span>):</div><div class="line">        (status_cmd,output_cmd) = commands.getstatusoutput(msg[<span class="string">'Text'</span>][<span class="number">1</span>:])</div><div class="line">	</div><div class="line">        <span class="keyword">return</span> <span class="string">u'return : '</span>+str(status_cmd)+<span class="string">u'\nresult : \n'</span> + str(output_cmd)</div><div class="line"></div><div class="line"><span class="comment">######### reply in normal #######</span></div><div class="line">    defaultReply = <span class="string">'I received: '</span> + msg[<span class="string">'Text'</span>]</div><div class="line"><span class="comment">######### reply by tuling #######</span></div><div class="line">    reply = get_response(msg[<span class="string">'Text'</span>])</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> reply <span class="keyword">or</span> defaultReply</div><div class="line"></div><div class="line">itchat.auto_login(hotReload=<span class="keyword">True</span>) </div><div class="line">itchat.run()</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Wechat </tag>
            
            <tag> Python2.6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[my_first_Markdown_Blog]]></title>
      <url>/2017/05/23/my-first-markdown-blog/</url>
      <content type="html"><![CDATA[<p>title: my_first_Markdown_Blog<br>date: 2017-05-23 01:01:31<br>categories: personal<br>tags:</p>
<h2 id="随想"><a href="#随想" class="headerlink" title="- 随想 "></a>- 随想 </h2><h3 id="个人感想"><a href="#个人感想" class="headerlink" title="个人感想"></a>个人感想</h3><h4 id="分享小故事"><a href="#分享小故事" class="headerlink" title="分享小故事"></a>分享小故事</h4><p>工作6个月左右的时候听到一个有趣的小故事<br><a id="more"></a></p>
<blockquote>
<p>镇上有一个富人，有一天听闻大城市回来一位在全国有名的大餐厅工作了好多年厨师，便高薪聘请做自己的私人厨师。富人按市里的规格给厨师配置了一套完整的厨房设施，然后让厨师给按市里的菜谱做菜。一眨眼俩小时上来一桌子菜，老板迫不及待拿起筷子尝了起来，刚吃第一口，眉头一皱，接着尝第二个，第三个。。。<br>老板不解的把厨师叫出来问：你这菜怎么做的，怎么这么难吃，不是大城市里大餐馆的厨师么，怎么做饭做的不如我的乡下厨师呢还</p>
<p>答：我在市里餐馆的时候是给餐馆大厨打下手的，从来没做过饭</p>
<p>问：打下手也不至于做的这么难吃吧，打下手都干什么呢</p>
<p>答：剥洋葱，这些年一直在剥洋葱</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>毕业一年多，也进入公司工作了一年，很庆幸刚毕业就有能进大公司工作，这里的工作环境，福利待遇，对一个刚毕业的本科生来说都是很友好的。这一年里，我迅速的学习掌握工作技能，以尽快的掌握和胜任工作的内容。</p>
<p>进步不止一点半点。所谓的进步不止在<code>linux</code>,<code>服务器</code>相关知识的学习和应用，更重要的是对工作的整体认识和把握，以及处理工作中各类问题的应变力和控制力。最最最重要的是对自己职业规划的探索和认识。</p>
<p>以前常常听到一种说法</p>
<blockquote>
<p>你毕业以后从事方向很有可能成为你未来事业发展方向</p>
</blockquote>
<p>姑且不论其是否正确，单对个人来说还是有其道理的，从毕业前大三大四实习到毕业后选择的职业方向，从最开始的不自信和探索，到对职业方向和自己的认同，逐步确立起了自己的发展方向。<strong>这无疑是我一年来最大的收获</strong></p>
<h4 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h4><p>对自己的发展方向有了初步认识以后，接下来就是向发展方向努力进步了。都说<em>刚毕业的前几年最应该努力学习</em>这一点不假，身边的人有的在考验有的在考证，无疑是为了将来有更好的出路。反倒自己浑浑噩噩了大半年，学习效率低下，实在是惭愧。</p>
<p>参加工作这一年多里，Team来来走走差不多换了一拨人，其中有一个前辈的话深深警醒着我。我问他来了这么久进步大么。他回答说<em>刚来的一年里学的东西多，进步挺大的，后来就是带案子做案子，也没有什么进步</em>，这不是在说以后的我么，我现在的菜鸟水平不就是那个刚学会剥洋葱的人（连洋葱还没有剥熟练），所以，<strong>努力学习寻求更大的发展空间才是硬道理啊！！！</strong></p>
<h5 id="但是，让我先把洋葱剥熟练了吧！！！"><a href="#但是，让我先把洋葱剥熟练了吧！！！" class="headerlink" title="但是，让我先把洋葱剥熟练了吧！！！"></a>但是，让我先把洋葱剥熟练了吧！！！</h5><p><a href="constmyheart@163.com">email to me</a></p>
<p><img src="http://i1.piimg.com/1949/414797c82b962f42.jpg" width="200" hight="200"></p>
]]></content>
      
        <categories>
            
            <category> personal </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 随想 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
